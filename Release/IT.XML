<?xml version="1.0"?>
<doc>
    <assembly>
        <name>IT</name>
    </assembly>
    <members>
        <member name="T:IT.Ap">
            <summary>
            Основные методы и свойства из класса System.Windows.Forms.Application + некоторые свои
            </summary>
        </member>
        <member name="P:IT.Ap.AppFolder">
            <summary>
            Папка с выполняемым файлом
            </summary>
        </member>
        <member name="P:IT.Ap.AppCaption">
            <summary>
            Заголовок программы
            </summary>
        </member>
        <member name="P:IT.Ap.CurAssembly">
            <summary>
            Возвращает процесс, исполняемый в домене приложения по умолчанию.В других
            доменах приложений это первый исполняемый процесс, который был выполнен методом
            System.AppDomain.ExecuteAssembly(System.String).
            </summary>
        </member>
        <member name="P:IT.Ap.HostName">
            <summary>
            Название этого компьютера
            </summary>
        </member>
        <member name="P:IT.Ap.IPAddress">
            <summary>
            IP-адрес этого компьютера
            </summary>
        </member>
        <member name="P:IT.Ap.IPAddressV6">
            <summary>
            IP-адрес v6 этого компьютера
            </summary>
        </member>
        <member name="P:IT.Ap.ProductName">
            <summary>
            Название программы
            </summary>
        </member>
        <member name="P:IT.Ap.TitleName">
            <summary>
            Название программы альтернативное
            </summary>
        </member>
        <member name="P:IT.Ap.AppFileVersionInfo">
            <summary>
            
            </summary>
        </member>
        <member name="P:IT.Ap.StrProductVersion">
            <summary>
            Версия программы
            </summary>
        </member>
        <member name="P:IT.Ap.ExecutablePath">
            <summary>
            
            </summary>
        </member>
        <member name="P:IT.Ap.ProductVersion">
            <summary>
            Версия программы
            </summary>
        </member>
        <member name="T:IT.CsvBase">
            <summary>
            Базовый класс для работы с основными операциями формата Csv
            </summary>
        </member>
        <member name="P:IT.CsvBase.DEFAULT_SEPARATOR">
            <summary>
            Дефолтный разделитель полей
            </summary>
        </member>
        <member name="P:IT.CsvBase.Separator">
            <summary>
            Разделитель полей
            </summary>
        </member>
        <member name="M:IT.CsvBase.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="T:IT.CsvReader`1">
            <summary>
            Класс для работы с основными операциями формата Csv. 
            </summary>
            <typeparam name="T">Тип обрабатываемых данных</typeparam>
        </member>
        <member name="P:IT.CsvReader`1.FilterSource">
            <summary>
            Запускается сразу после прочтения файла
            </summary>
        </member>
        <member name="P:IT.CsvReader`1.Items">
            <summary>
            Прочитанные сущности
            </summary>
        </member>
        <member name="M:IT.CsvReader`1.#ctor(System.Func{System.String[],`0})">
            <summary>
            ctor
            </summary>
            <param name="creator"></param>
        </member>
        <member name="M:IT.CsvReader`1.Load(System.String,System.Int32,System.Func{System.String[],`0})">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <param name="splitCount"></param>
            <param name="creator"></param>
            <returns></returns>
        </member>
        <member name="T:IT.CsvReader">
            <summary>
            Упрощенный класс для работы с основными операциями формата Csv. 
            </summary>
        </member>
        <member name="M:IT.CsvReader.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="T:IT.CsvWriter`1">
            <summary>
            Класс для работы с основными операциями формата Csv. Понимает атрибуты DisplayNameAttribute и DescriptionAttribute
            </summary>
            <typeparam name="T">Тип обрабатываемых данных</typeparam>
        </member>
        <member name="M:IT.CsvWriter`1.Create(System.String[])">
            <summary>
            Создает Csv с указанными полями (пересечение) и порядком следования
            </summary>
            <param name="fields">Позволяет ограничить/фильтровать состав полей, указанными</param>
            <returns></returns>
        </member>
        <member name="M:IT.CsvWriter`1.UsingCsv(System.Action{IT.CsvWriter{`0}},IT.CsvWriter{`0})">
            <summary>
            Предоставляет готовый экземпляр для удобной работы с ним
            </summary>
            <param name="act"></param>
            <param name="existingItem"></param>
        </member>
        <member name="P:IT.CsvWriter`1.ItemPropertyes">
            <summary>
            Набор свойств указанного типа
            </summary>
        </member>
        <member name="M:IT.CsvWriter`1.#ctor(System.Reflection.PropertyInfo[])">
            <summary>
            Конструктор
            </summary>
            <param name="itemPropertyes">Набор свойств указанного типа</param>
        </member>
        <member name="M:IT.CsvWriter`1.#ctor">
            <summary>
            Конструктор
            </summary>
        </member>
        <member name="M:IT.CsvWriter`1.#ctor(System.Reflection.PropertyInfo[],System.Func{`0,System.String})">
            <summary>
            Конструктор
            </summary>
            <param name="pis">Набор свойств указанного типа</param>
            <param name="getRow">Метод получения строки данных указанного объекта</param>
        </member>
        <member name="M:IT.CsvWriter`1.#ctor(System.Func{`0,System.String})">
            <summary>
            Конструктор
            </summary>
            <param name="getRow">Метод получения строки данных указанного объекта</param>
        </member>
        <member name="M:IT.CsvWriter`1.GetHeader">
            <summary>
            Метод получения заголовка
            </summary>
            <returns></returns>
        </member>
        <member name="M:IT.CsvWriter`1.GetRow(`0)">
            <summary>
            Метод получения строки данных указанного объекта
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:IT.CsvWriter`1.Serialize(System.Collections.Generic.IEnumerable{`0},System.IO.Stream,System.Boolean)">
            <summary>
            Метод запиви набора данных в выходной потокововый объект
            </summary>
            <param name="list">Исходный набор данных</param>
            <param name="outStream"></param>
            <param name="includeHeader"></param>
        </member>
        <member name="M:IT.CsvWriter`1.ToStream(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
            Создает и заполняет MemoryStream
            </summary>
            <param name="list"></param>
            <param name="includeHeader"></param>
            <returns></returns>
        </member>
        <member name="M:IT.CsvWriter`1.Write(System.Collections.Generic.IEnumerable{`0},System.IO.TextWriter,System.Boolean)">
            <summary>
            Метод запиви набора данных в выходной потокововый объект
            </summary>
            <param name="list">Исходный набор данных</param>
            <param name="tw"></param>
            <param name="includeHeader">Записывать ли заголовок</param>
        </member>
        <member name="M:IT.CsvWriter`1.GetHeaderCore">
            <summary>
            Метод получения заголовка
            </summary>
            <returns></returns>
        </member>
        <member name="M:IT.CsvWriter`1.GetRowCore(`0)">
            <summary>
            Метод получения строки данных указанного объекта
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:IT.CsvWriter`1.UsingProps(System.Func{System.Reflection.PropertyInfo,System.String})">
            <summary>
            Вспомогательный метод получения строки из предоставляемых полей
            </summary>
            <param name="getPropertyValue"></param>
            <returns></returns>
        </member>
        <member name="T:IT.Data.DataAdapterBase">
            <summary>
            Класс, ипользующий одно соединение, который предоставляет метод для кеширования DbCommand : Сmd()/>
            </summary>
        </member>
        <member name="F:IT.Data.DataAdapterBase._cmdCache">
            <summary>
            Кэш команд
            </summary>
        </member>
        <member name="P:IT.Data.DataAdapterBase.Connection">
            <summary>
            Реализация интерфейса IDataAdapterBase
            </summary>
        </member>
        <member name="M:IT.Data.DataAdapterBase.Cmd(System.String,System.Data.CommandType,System.String[])">
            <summary>
            Получение/создание кешированного DbCommand (параметры не должны вызывать затруднений ;)
            </summary>
            <param name="sql"></param>
            <param name="type"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Data.DataAdapterBase.#ctor(System.Data.IDbConnection)">
            <summary>
            ctor
            </summary>
            <param name="conn">Соединение для создания комманд</param>
        </member>
        <member name="M:IT.Data.DataAdapterBase.Dispose(System.Boolean)">
            <summary>
            Реализация интерфейса IDisposable
            </summary>
        </member>
        <member name="T:IT.Data.Db_Extentions">
            <summary>
            Расширения для некоторых классов пространства имен System.Data.Common
            </summary>
        </member>
        <member name="M:IT.Data.Db_Extentions.IsActive(System.Data.IDbConnection)">
            <summary>
            Показывает состояние соединения
            </summary>
            <returns></returns>
        </member>
        <member name="M:IT.Data.Db_Extentions.CloseIfNotClosed(System.Data.IDbConnection)">
            <summary>
            Проверяет состояние соединения и, если не закрыто, то закрывает его
            </summary>
        </member>
        <member name="M:IT.Data.Db_Extentions.OpenIfClosed(System.Data.IDbConnection)">
            <summary>
            Проверяет состояние соединения и, если не открыто, то открывает его
            </summary>
        </member>
        <member name="M:IT.Data.Db_Extentions.CreateCommand(System.Data.IDbConnection,System.String,System.Data.CommandType,System.String[])">
            <summary>
            Создает объект DbCommand из данного соединения
            </summary>
            <param name="Connection">Расширяемый экземпляр</param>
            <param name="sql">Текст запорса</param>
            <param name="type">тип запроса</param>
            <param name="parameters">Набор имен нетипизированых параметров</param>
            <returns>Заполненая соответствующими параметрами DbCommand</returns>
        </member>
        <member name="M:IT.Data.Db_Extentions.DoWork(System.Data.IDbConnection,System.Action{System.Data.IDbConnection})">
            <summary>
            Предоставляет открытое соединение, если до этого соединение было закрыто - закрывает его после работы
            Исключения НЕ обрабатываются
            </summary>
            <param name="conn">Расширяемый экземпляр</param>
            <param name="OpenedConnection"></param>
        </member>
        <member name="M:IT.Data.Db_Extentions.DoWork``1(System.Data.IDbConnection,System.Func{System.Data.IDbConnection,``0})">
            <summary>
            Предоставляет открытое соединение, если до этого соединение было закрыто - закрывает его после работы
            Исключения НЕ обрабатываются
            </summary>
            <param name="conn">Расширяемый экземпляр</param>
            <param name="OpenedConnection"></param>
        </member>
        <member name="M:IT.Data.Db_Extentions.DoWorkInTran(System.Data.IDbConnection,System.Action{System.Data.IDbTransaction},System.Data.IDbTransaction,System.Boolean)">
            <summary>
            Предоставляет работу внутри транзакции (и открытое соединение). Возвращает успех транзакции.
            с externalTran никаких действий не производится, передается как есть.
            </summary>
            <param name="conn">Расширяемый экземпляр</param>
            <param name="usingTran"></param>
            <param name="externalTran">Внешняя транзакция</param>
            <param name="isNeedTransaction">Следует ли создавать отдельную транзакцию (актуально при transaction == null)</param>
            <returns></returns>
        </member>
        <member name="M:IT.Data.Db_Extentions.DoWorkInTran``1(System.Data.IDbConnection,System.Func{System.Data.IDbTransaction,``0},System.Data.IDbTransaction,System.Boolean)">
            <summary>
            Предоставляет работу внутри транзакции (и открытое соединение). Возвращает успех транзакции.
            с externalTran никаких действий не производится, передается как есть.
            </summary>
            <param name="Connection">Расширяемый экземпляр</param>
            <param name="usingTran"></param>
            <param name="externalTran">Внешняя транзакция</param>
            <param name="isNeedTransaction">Следует ли создавать отдельную транзакцию (актуально при transaction == null)</param>
            <returns></returns>
        </member>
        <member name="M:IT.Data.Db_Extentions.ExecuteScalarInTran(System.Data.IDbConnection,System.String,System.Data.IDbTransaction,System.Boolean)">
            <summary>
            Выполняет команду в контексте указанной транзакции
            При этом открывается соединение, и закрывается (если до этого было закрыто)
            </summary>
            <param name="con">Расширяемый экземпляр</param>
            <param name="sql">Текст команды</param>
            <param name="transaction">Транзакция, в контесте которой выполняется команда</param>
            <param name="isNeedTransaction">Следует ли создавать отдельную транзакцию (актуально при transaction == null)</param>
            <returns></returns>
        </member>
        <member name="M:IT.Data.Db_Extentions.SetParameter(System.Data.IDbCommand,System.String,System.Object)">
            <summary>
            Добавляет нетипизированый параметр, и возвращает его для указания прочих свойств
            </summary>
            <param name="cmd">Расширяемый экземпляр</param>
            <param name="paramName">Наименование параметра (допускается впереди указать направление как [ in, Input, inout, InputOutput, out, Output, ret, ReturnValue ] без учета регистра)</param>
            <param name="value">value</param>
            <returns>Привязаный к команде параметр</returns>
        </member>
        <member name="M:IT.Data.Db_Extentions.AppendParam(System.Data.IDbCommand,System.String)">
            <summary>
            Добавляет нетипизированый параметр, и возвращает его для указания прочих свойств
            </summary>
            <param name="cmd">Расширяемый экземпляр</param>
            <param name="paramName">Наименование параметра (допускается впереди указать направление как [ in, Input, inout, InputOutput, out, Output, ret, ReturnValue ] без учета регистра)</param>
            <returns>Привязаный к команде параметр</returns>
        </member>
        <member name="M:IT.Data.Db_Extentions.ExecuteNonQueryInTran(System.Data.IDbCommand,System.Data.IDbTransaction,System.Boolean)">
            <summary>
            Выполняет команду в контексте указанной транзакции
            При этом открывается соединение, и закрывается (если до этого было закрыто)
            </summary>
            <param name="cmd">Расширяемый экземпляр</param>
            <param name="externalTran">Транзакция, в контесте которой выполняется команда</param>
            <param name="isNeedTransaction">Следует ли создавать отдельную транзакцию (актуально при transaction == null)</param>
            <returns></returns>
        </member>
        <member name="M:IT.Data.Db_Extentions.ExecuteNonQueryInTran(System.Data.IDbCommand,System.TimeSpan@,System.Data.IDbTransaction,System.Boolean)">
            <summary>
            Выполняет команду в контексте указанной транзакции
            При этом открывается соединение, и закрывается (если до этого было закрыто)
            </summary>
            <param name="cmd">Расширяемый экземпляр</param>
            <param name="ts">Время выполнения команды</param>
            <param name="externalTran">Транзакция, в контесте которой выполняется команда</param>
            <param name="isNeedTransaction">Следует ли создавать отдельную транзакцию (актуально при transaction == null)</param>
            <returns></returns>
        </member>
        <member name="M:IT.Data.Db_Extentions.ExecuteReaderInTran(System.Data.IDbCommand,System.Predicate{System.Data.IDataReader},System.Data.IDbTransaction,System.Boolean)">
            <summary>
            Выполняет команду в контексте указанной транзакции
            При этом открывается соединение, и закрывается (если до этого было закрыто)
            Возврвщает были ли записи в наборе
            </summary>
            <param name="cmd">Расширяемый экземпляр</param>
            <param name="readRecord">Метод, использующий каждую запись DbDataReader. Выполняется, пока не вернет false или DbDataReader достигнет конца</param>
            <param name="externalTran">Транзакция, в контесте которой выполняется команда</param>
            <param name="isNeedTransaction">Следует ли создавать отдельную транзакцию (актуально при transaction == null)</param>
            <returns>Были ли записи в наборе</returns>
        </member>
        <member name="M:IT.Data.Db_Extentions.ExecuteScalarInTran(System.Data.IDbCommand,System.Data.IDbTransaction,System.Boolean)">
            <summary>
            Выполняет команду в контексте указанной транзакции
            При этом открывается соединение, и закрывается (если до этого было закрыто)
            </summary>
            <param name="cmd">Расширяемый экземпляр</param>
            <param name="externalTran">Транзакция, в контесте которой выполняется команда</param>
            <param name="isNeedTransaction">Следует ли создавать отдельную транзакцию (актуально при transaction == null)</param>
            <returns></returns>
        </member>
        <member name="M:IT.Data.Db_Extentions.ExecuteListReflection``1(System.Data.IDbCommand,System.Data.IDbTransaction,System.Boolean)">
            <summary>
            Выполняя ExecuteReaderInTran() вычитывает все записи в результат.
            Возвращает заполненный список записей
            </summary>
            <typeparam name="T">IDtoBase_Reader, new()</typeparam>
            <param name="cmd">Расширяемый экземпляр</param>
            <param name="externalTran">Транзакция, в контесте которой выполняется команда</param>
            <param name="isNeedTransaction">Следует ли создавать отдельную транзакцию (актуально при transaction == null)</param>
            <returns>Заполненный список записей</returns>
        </member>
        <member name="M:IT.Data.Db_Extentions.Get``1(System.Data.IDataReader,System.Int32,``0)">
            <summary>
            Returns the value of the specified field or defaultValue, converted to the specified type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dr"></param>
            <param name="ordinal">The index of the field</param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Data.Db_Extentions.Get``1(System.Data.IDataReader,System.String,``0)">
            <summary>
            Returns the value of the specified field or defaultValue, converted to the specified type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dr"></param>
            <param name="paramName">The name of the field</param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Data.Db_Extentions.To``1(System.Object,``0)">
            <summary>
            Trying to return the value of the specified type, or defaultValue
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="T:IT.Data.Dto_Base">
            <summary>
            Стандартный справочник
            </summary>
        </member>
        <member name="P:IT.Data.Dto_Base.RowState">
            <summary>
            Состояние записи
            </summary>
        </member>
        <member name="P:IT.Data.Dto_Base.Id">
            <summary>
            Ключ, Browsable(false)
            </summary>
        </member>
        <member name="P:IT.Data.Dto_Base.Name">
            <summary>
            Значение
            </summary>
        </member>
        <member name="M:IT.Data.Dto_Base.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:IT.Data.Dto_Base.Init(System.Data.IDataReader)">
            <summary>
            Реализация интерфейса IDtoBase_Reader
            </summary>
            <param name="dr"></param>
        </member>
        <member name="M:IT.Data.Dto_Base.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:IT.Data.IDto_Reader">
            <summary>
            Интерфейс, используемый для расширения  List%3CT%3E ExecuteList%3CT%3E(this DbCommand cmd, DbTransaction transaction = null) where T : IDtoBase_Reader, new()'
            </summary>
        </member>
        <member name="M:IT.Data.IDto_Reader.Init(System.Data.IDataReader)">
            <summary>
            Заполняет себя данными из DbDataReader
            </summary>
            <param name="dr">Открытый и готовый для считывания одной записи DbDataReader</param>
        </member>
        <member name="T:IT.Data.IDto_RowState">
            <summary>
            Сущность имеет стстояние записи
            </summary>
        </member>
        <member name="P:IT.Data.IDto_RowState.RowState">
            <summary>
            Состояние записи
            </summary>
        </member>
        <member name="T:IT.IInvoke">
            <summary>
            Интерфейс для расширения возможностей класса за счет IInvoke_Extention
            (AppInvoke(), AppBeginInvoke(), GoAsynk(), ActionDelay()
            </summary>
        </member>
        <member name="T:IT.IInvoke_Extention">
            <summary>
            Extentions class to IInvoke
            </summary>
        </member>
        <member name="P:IT.IInvoke_Extention.Context">
            <summary>
            Presumably context for UI
            </summary>
        </member>
        <member name="M:IT.IInvoke_Extention.AppInvoke(IT.IInvoke,System.Action,System.Action{System.Exception})">
            <summary>
            Выполнение act в главном потоке 
            </summary>
            <param name="sender">Расширяемый интерфейс</param>
            <param name="act">Действие</param>
            <param name="onError">Метод обработки исключений</param>
        </member>
        <member name="M:IT.IInvoke_Extention.GoAsync(IT.IInvoke,System.Action,System.Action{System.TimeSpan},System.Action{System.Exception})">
            <summary>
            Выполнение задачи в ThreadPool с подсчетом времени, запускат onFynally/onError в контексте вызывавшего потока
            </summary>
            <param name="sender">Расширяемый интерфейс</param>
            <param name="doWork">Метод, выполняющий полезную работу</param>
            <param name="onError">Метод, вызываемый при ошибке</param>
            <param name="onFynally"></param>
        </member>
        <member name="M:IT.IInvoke_Extention.GoAsync``1(IT.IInvoke,System.Func{``0},System.Action{``0},System.Action{System.TimeSpan},System.Action{System.Exception})">
            <summary>
            Выполнение задачи в ThreadPool с подсчетом времени, запускат onFynally/onError в контексте вызывавшего потока
            Выполнение задачи в Task с подсчетом времени
            </summary>
            <param name="sender">Расширяемый интерфейс</param>
            <param name="doWork"></param>
            <param name="onComplete"></param>
            <param name="onError"></param>
            <param name="onFynally"></param>
        </member>
        <member name="M:IT.IInvoke_Extention.ActionDelay(IT.IInvoke,System.Action,System.Int32)">
            <summary>
            Выполняет указанное действие по истечению указанного времени
            </summary>
            <param name="sender">Расширяемый интерфейс</param>
            <param name="action"></param>
            <param name="delaySecond"></param>
        </member>
        <member name="M:IT.IInvoke_Extention.Exec(System.Threading.SynchronizationContext,System.Action,System.Boolean)">
            <summary>
            Выполняет метод act в указанном контексте, если указан
            </summary>
            <param name="context"></param>
            <param name="act"></param>
            <param name="isAsysnc"></param>
        </member>
        <member name="M:IT.IInvoke_Extention.Exec``1(System.Threading.SynchronizationContext,System.Action{``0},``0,System.Boolean)">
            <summary>
            Выполняет метод act в указанном контексте, если указан
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="act"></param>
            <param name="value"></param>
            <param name="isAsysnc"></param>
        </member>
        <member name="T:IT.MemCache`2">
            <summary>
            Удобный справочник, который не ругается на ключи
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:IT.MemCache`2.Item(`0)">
            <summary>
            Не ругается на запрос отсутствующего ключа
            </summary>
            <param name="key">Ключ</param>
            <returns></returns>
        </member>
        <member name="P:IT.MemCache`2.Item(`0,System.Func{`1})">
            <summary>
            Позволяет создать значение указанного ключа из getValue/>
            </summary>
            <param name="key">Ключ</param>
            <param name="getValue">Метод получения значения</param>
            <returns></returns>
        </member>
        <member name="M:IT.MemCache`2.GetValue(`0,System.Func{`1})">
            <summary>
            Контроль наследников над получением значения
            </summary>
            <param name="key"></param>
            <param name="getValue"></param>
            <returns></returns>
        </member>
        <member name="M:IT.MemCache`2.SetValue(`0,`1)">
            <summary>
            Контроль наследниников над установкой значения
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="T:IT.Assembly_Extention">
            <summary>
            Extention methods for Assembly
            </summary>
        </member>
        <member name="M:IT.Assembly_Extention.GetCustomAttributes``1(System.Reflection.Assembly)">
            <summary>
            Получение всех TAttribute из атрибутов сборки
            </summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Assembly_Extention.GetCustomAttribute``1(System.Reflection.Assembly)">
            <summary>
            Получение TAttribute из атрибутов сборки
            </summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Assembly_Extention.GetAppFileVersionInfo(System.Reflection.Assembly)">
            <summary>
            
            </summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Assembly_Extention.GetInformationalVersionAttribute(System.Reflection.Assembly)">
            <summary>
            Возвращает значение атрибута из AssemblyInfo.cs
            </summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Assembly_Extention.GetExecutablePath(System.Reflection.Assembly)">
            <summary>
            
            </summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Assembly_Extention.GetProductAttribute(System.Reflection.Assembly)">
            <summary>
            Возвращает значение атрибута из AssemblyInfo.cs
            </summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Assembly_Extention.GetTitleAttribute(System.Reflection.Assembly)">
            <summary>
            Возвращает значение атрибута из AssemblyInfo.cs
            </summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Assembly_Extention.GetProductName(System.Reflection.Assembly)">
            <summary>
            Вычисление ProductName 3-мя способами
            </summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Assembly_Extention.GetStrProductVersion(System.Reflection.Assembly)">
            <summary>
            Вычисление Productversion 2-мя способами
            </summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Assembly_Extention.UsingAssembly``1(System.Func{System.Reflection.Assembly,``0},System.String)">
            <summary>
            It provides for the use of checked object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="act"></param>
            <param name="methodName"></param>
            <returns></returns>
        </member>
        <member name="T:IT.String_Extentions">
            <summary>
            Расширения для string
            </summary>
        </member>
        <member name="F:IT.String_Extentions.TRUE_WORDS">
            <summary>
            Варианты строк в нижнем регистре, обозначающие позитивное значение bool
            </summary>
        </member>
        <member name="F:IT.String_Extentions.DecimalSeparator">
            <summary>
            Разделитель целой и дробной части, используемые в системе
            </summary>
        </member>
        <member name="M:IT.String_Extentions.ReplaceDecimalSeparator(System.String)">
            <summary>
            Замена символов '.' и ',' на  System.Globalization.CultureInfo.CurrentCulture.NumberFormat.CurrencyDecimalSeparator
            </summary>
            <param name="s">Расширяемый экземпляр</param>
            <returns></returns>
        </member>
        <member name="M:IT.String_Extentions.To``1(System.String)">
            <summary>
            Применяет "TryParse" для указанного типа
            </summary>
            <typeparam name="T"></typeparam>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:IT.String_Extentions.TryParse``1(System.String,``0@)">
            <summary>
            Пытаерся применить typeof(T).TryParse()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="s"></param>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:IT.String_Extentions.To``1(System.String,``0)">
            <summary>
            Применяет "TryParse" (если есть) для указанного типа
            инче возвращает default(T)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="s"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:IT.String_Extentions.ToDef``1(System.String)">
            <summary>
            Применяет "TryParse" (если есть) для указанного типа
            инче возвращает default(T)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:IT.String_Extentions.ToBool(System.String,System.Boolean)">
            <summary>
            Как правило актуально для импорта
            </summary>
            <param name="s"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:IT.String_Extentions.Split(System.String,System.StringSplitOptions,System.Char[])">
            <summary>
            Возвращает строковый массив, содержащий подстроки данной строки, разделенные
            элементами заданного массива знаков Юникода.Параметр указывает, следует ли
            возвращать пустые элементы массива.
            </summary>
            <param name="s">Расширяемый экземпляр</param>
            <param name="options">System.StringSplitOptions.RemoveEmptyEntries, чтобы исключить пустые элементы из возвращаемого массива; или System.StringSplitOptions.None для включения пустых элементов в возвращаемый массив.</param>
            <param name="separator">Массив знаков Юникода, разделяющих подстроки в данной строке, пустой массив, не содержащий разделителей, или null.</param>
            <returns>Массив, элементы которого содержат подстроки данной строки, разделенные одним или более знаками из separator.Дополнительные сведения см. в разделе "Примечания".</returns>
        </member>
        <member name="M:IT.String_Extentions.ToTranslit(System.String)">
            <summary>
            Перевод русского текста в латиницу + ToUpper()
            </summary>
            <param name="s">Исходная строка</param>
            <returns></returns>
        </member>
        <member name="T:IT.Type_Extention">
            <summary>
            Extention methods for Type
            </summary>
        </member>
        <member name="M:IT.Type_Extention.FromNullable(System.Type)">
            <summary>
            Type extracts from Nullable of Type
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Type_Extention.GetProperties(System.Type,System.Boolean)">
            <summary>
            PropertyInfo extracts from Type (include interaces)
            </summary>
            <param name="type"></param>
            <param name="isFiltered"></param>
            <returns></returns>
        </member>
        <member name="T:IT.MyLookupBindingPropertiesAttribute">
            <summary>
            Замена атрибута System.ComponentModel.LookupBindingPropertiesAttribute
            Появление данного атрибута обусловлено тем, что в арибуре AttributeUsage класса LookupBindingPropertiesAttribute провтыкали установить AllowMultiple = true, без чего невозможно а одном классе использовать несколько Lookup-полей
            </summary>
        </member>
        <member name="P:IT.MyLookupBindingPropertiesAttribute.DataSource">
            <summary>
            Gets the name of the data source property for the component this attribute is bound to.
            Возвращает имя свойства источника данных для LookupMember, к которому привязан этот атрибут.
            </summary>
        </member>
        <member name="P:IT.MyLookupBindingPropertiesAttribute.DisplayMember">
            <summary>
            Gets the name of the display member property for the component this attribute is bound to.
            Возвращает имя свойства элемента отображения для компонента, к которому привязан DataSource.
            </summary>
        </member>
        <member name="P:IT.MyLookupBindingPropertiesAttribute.LookupMember">
            <summary>
            Gets the name of the  member property for the component this attribute is bound to.
            Возвращает имя свойства наэначения для компонента, к которому привязан этот атрибут.
            </summary>
        </member>
        <member name="P:IT.MyLookupBindingPropertiesAttribute.ValueMember">
            <summary>
            Gets the name of the value member property for the component this attribute is bound to.
            Возвращает имя свойства элемента значения для компонента, к которому привязан этот атрибут.
            </summary>
        </member>
        <member name="M:IT.MyLookupBindingPropertiesAttribute.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            .ctor
            </summary>
            <param name="dataSource"></param>
            <param name="displayMember"></param>
            <param name="valueMember"></param>
            <param name="lookupMember"></param>
        </member>
        <member name="T:IT.NotifyPropertyChangedOnly">
            <summary>
            Простая реализация INotifyPropertyChanged
            </summary>
        </member>
        <member name="E:IT.NotifyPropertyChangedOnly.PropertyChanged">
            <summary>
            INotifyPropertyChanged
            </summary>
        </member>
        <member name="M:IT.NotifyPropertyChangedOnly.OnPropertyChanged(System.String)">
            <summary>
            Упрощение вызова для наследников
            </summary>
            <param name="propertyName">Имя изменяемого свойства</param>
        </member>
        <member name="E:IT.NotifyPropertyChangedOnly.PropertyChanging">
            <summary>
            INotifyPropertyChanging
            </summary>
        </member>
        <member name="M:IT.NotifyPropertyChangedOnly.OnPropertyChanging(System.String)">
            <summary>
            Упрощение вызова для наследников
            </summary>
            <param name="propertyName">Имя изменяемого свойства</param>
        </member>
        <member name="T:IT.NotifyPropertyChangedBase">
            <summary>
            Простая реализация INotifyPropertyChanged, наследуется от Disposable
            </summary>
        </member>
        <member name="E:IT.NotifyPropertyChangedBase.PropertyChanged">
            <summary>
            INotifyPropertyChanged
            </summary>
        </member>
        <member name="M:IT.NotifyPropertyChangedBase.OnPropertyChanged(System.String)">
            <summary>
            Упрощение вызова для наследников
            </summary>
            <param name="propertyName">Имя изменяемого свойства</param>
        </member>
        <member name="E:IT.NotifyPropertyChangedBase.PropertyChanging">
            <summary>
            INotifyPropertyChanging
            </summary>
        </member>
        <member name="M:IT.NotifyPropertyChangedBase.OnPropertyChanging(System.String)">
            <summary>
            Упрощение вызова для наследников
            </summary>
            <param name="propertyName">Имя изменяемого свойства</param>
        </member>
        <member name="T:IT.NotifyPropertyChangedBaseEx">
            <summary>
            NotifyPropertyChangedBase + проверку наличия изменяемого свойства
            </summary>
        </member>
        <member name="P:IT.NotifyPropertyChangedBaseEx.SelfProperties">
            <summary>
            Все свойства данного класса
            </summary>
        </member>
        <member name="P:IT.NotifyPropertyChangedBaseEx.ThrowOnInvalidPropertyName">
            <summary>
            Выполнять ли проверку наличия изменяемого свойства
            </summary>
        </member>
        <member name="M:IT.NotifyPropertyChangedBaseEx.#ctor">
            <summary>
            Конструктор
            </summary>
        </member>
        <member name="M:IT.NotifyPropertyChangedBaseEx.VerifyPropertyName(System.String)">
            <summary>
            Проверка наличия свойства
            </summary>
            <param name="propertyName">Имя проверяемого свойства</param>
        </member>
        <member name="M:IT.NotifyPropertyChangedBaseEx.ToString">
            <summary>
            Возвращает короткое имя типа
            </summary>
            <returns></returns>
        </member>
        <member name="M:IT.NotifyPropertyChangedBaseEx.OnPropertyChanged(System.String)">
            <summary>
            Упрощение вызова для наследников
            </summary>
            <param name="propertyName">Имя изменяемого свойства</param>
        </member>
        <member name="M:IT.NotifyPropertyChangedBaseEx.OnPropertyChanging(System.String)">
            <summary>
            Упрощение вызова для наследников
            </summary>
            <param name="propertyName">Имя изменяемого свойства</param>
        </member>
        <member name="T:IT.Serializer_Json">
            <summary>
            Скриализатор в/из вайлов фрмата json
            </summary>
        </member>
        <member name="F:IT.Serializer_Json.KnownTypes">
            <summary>
            изначально известные сложные типы
            </summary>
        </member>
        <member name="M:IT.Serializer_Json.SerializeDataContract(System.Object,System.IO.Stream,System.Type[])">
            <summary>
            Метод сериализации в поток
            </summary>
            <param name="item"></param>
            <param name="stream"></param>
            <param name="knownTypes"></param>
        </member>
        <member name="M:IT.Serializer_Json.Serialize_ToFile(System.Object,System.String,System.Type[])">
            <summary>
            Сериализация посредством DataContractJsonSerializer
            </summary>
            <param name="item"></param>
            <param name="file"></param>
            <param name="knownTypes"></param>
        </member>
        <member name="M:IT.Serializer_Json.Serialize_ToStream(System.Object,System.Type[])">
            <summary>
            Сериализация посредством DataContractJsonSerializer
            </summary>
            <param name="item"></param>
            <param name="knownTypes"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Serializer_Json.Serialize_ToString(System.Object,System.Type[])">
            <summary>
            Сериализация посредством DataContractJsonSerializer
            </summary>
            <param name="item"></param>
            <param name="knownTypes"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Serializer_Json.Deserialize``1(System.IO.Stream,System.Type[])">
            <summary>
            Метод десериализации из файла
            </summary>
            <typeparam name="TRes"></typeparam>
            <param name="stream"></param>
            <param name="knownTypes"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Serializer_Json.Deserialize``1(System.String,System.Type[])">
            <summary>
            
            </summary>
            <typeparam name="TRes"></typeparam>
            <param name="content"></param>
            <param name="knownTypes"></param>
            <returns></returns>
        </member>
        <member name="T:IT.Serializer">
            <summary>
            Сериализация объектов
            </summary>
        </member>
        <member name="M:IT.Serializer.Deserialize(System.IO.Stream,System.Runtime.Serialization.IFormatter)">
            <summary>
            Десериализация обекта из потока
            </summary>
            <param name="str">Входной поток</param>
            <param name="formater"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Serializer.DeserializeCollection``1(System.IO.Stream,System.Runtime.Serialization.IFormatter)">
            <summary>
            Десериализация обекта из потока
            </summary>
            <typeparam name="T"></typeparam>
            <param name="str">Входной поток</param>
            <param name="formater"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Serializer.Serialize(System.Object,System.IO.Stream,System.Runtime.Serialization.IFormatter)">
            <summary>
            Сериализация объекта в поток
            </summary>
            <param name="data"></param>
            <param name="str"></param>
            <param name="formater"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Serializer.Serialize(System.Object,System.Runtime.Serialization.IFormatter)">
            <summary>
            Сериализация объекта в Base64String
            </summary>
            <param name="data"></param>
            <param name="formater"></param>
            <returns></returns>
        </member>
        <member name="T:IT.Disposable">
            <summary>
            Заготовка для упрщенной реализации IDisposable ( void Dispose(bool disposing) + bool IsDisposed + void VerifyDisposed() + логирование)
            </summary>
        </member>
        <member name="P:IT.Disposable.IsDisposed">
            <summary>
            Признак уничтожения обЪекта
            </summary>
        </member>
        <member name="M:IT.Disposable.#ctor">
            <summary>
            Конструктор
            </summary>
        </member>
        <member name="M:IT.Disposable.Dispose(System.Boolean)">
            <summary>
            Метод интерфейса для перекрытия
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:IT.Disposable.Dispose">
            <summary>
            Реализзация интерфейса
            </summary>
        </member>
        <member name="M:IT.Disposable.VerifyDisposed">
            <summary>
            Если объект уже уничтожен - запускает исключение ObjectDisposedException()
            </summary>
        </member>
        <member name="T:IT.WPF.DataGridFilter">
            <summary>
            Присоединенные свойства для использования фильтрации
            </summary>
        </member>
        <member name="F:IT.WPF.DataGridFilter.HeadegFilter_DockButtom_TemplateKey">
            <summary>Template для заголовка в общем </summary>
        </member>
        <member name="F:IT.WPF.DataGridFilter.HeadegFilter_DockRight_TemplateKey">
            <summary>Template для заголовка в общем </summary>
        </member>
        <member name="F:IT.WPF.DataGridFilter.DataGridFilters_ComboBox_TemplateKey">
            <summary> Template для фильтра для столбца, представленного DataGridTextColumn. </summary>
        </member>
        <member name="F:IT.WPF.DataGridFilter.DataGridFilters_TextBoxContains_TemplateKey">
            <summary> Template для фильтра для столбца, представленного DataGridTextColumn. </summary>
        </member>
        <member name="F:IT.WPF.DataGridFilter.Icon_TemplateKey">
            <summary>The filter icon template.</summary>
        </member>
        <member name="F:IT.WPF.DataGridFilter.Icon_StyleKey">
            <summary>The filter icon style.</summary>
        </member>
        <member name="F:IT.WPF.DataGridFilter.SearchTextBox_StyleKey">
            <summary> Style for the filter text box in a filtered DataGridTextColumn. </summary>
        </member>
        <member name="F:IT.WPF.DataGridFilter.ComboBox_StyleKey">
            <summary> Style for the filter ComboBox in a filtered DataGridTextColumn. </summary>
        </member>
        <member name="F:IT.WPF.DataGridFilter.SearchTextBoxClearButton_StyleKey">
            <summary> Style for the clear button in the filter text box in a filtered DataGridTextColumn. </summary>
        </member>
        <member name="F:IT.WPF.DataGridFilter.AutoFilterProperty">
            <summary> Включение простого автофильтра как в excel </summary>
        </member>
        <member name="M:IT.WPF.DataGridFilter.GetAutoFilter(System.Windows.Controls.DataGrid)">
            <summary> </summary>
            <param name="dg"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.DataGridFilter.SetAutoFilter(System.Windows.Controls.DataGrid,IT.WPF.Filters.DataGridFilters)">
            <summary> </summary>
            <param name="dg"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:IT.WPF.DataGridFilter.GlobalFilterProperty">
            <summary> Позволяет указать глобальный фильтр, который применяется к элементам в дополнение к фильтрам столбцов. </summary>
        </member>
        <member name="M:IT.WPF.DataGridFilter.GetGlobalFilter(System.Windows.Controls.DataGrid)">
            <summary>
            Gets the value of the <see cref="P:IT.WPF.GlobalFilter" /> attached property from a given <see cref="T:System.Windows.Controls.DataGrid" />.
            </summary>
            <param name="obj">The <see cref="T:System.Windows.Controls.DataGrid" /> from which to read the property value.</param>
            <returns>the value of the <see cref="P:DataGridExtensions.GlobalFilter" /> attached property.</returns>
            <requires csharp="obj != null" vb="obj &lt;&gt; Nothing">obj != null</requires>
        </member>
        <member name="M:IT.WPF.DataGridFilter.SetGlobalFilter(System.Windows.Controls.DataGrid,System.Predicate{System.Object})">
            <summary>
            Sets the value of the <see cref="P:IT.WPF.GlobalFilter" /> attached property to a given <see cref="T:System.Windows.Controls.DataGrid" />.
            </summary>
            <param name="obj">The <see cref="T:System.Windows.Controls.DataGrid" /> on which to set the property value.</param>
            <param name="value">The property value to set.</param>
            <requires csharp="obj != null" vb="obj &lt;&gt; Nothing">obj != null</requires>
        </member>
        <member name="M:IT.WPF.DataGridFilter.GlobalFilter_Changed(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <requires csharp="d != null" vb="d &lt;&gt; Nothing">d != null</requires>
        </member>
        <member name="M:IT.WPF.DataGridFilter.GetContentFilterFactory(System.Windows.Controls.DataGrid)">
            <summary> получение фабрики фильтров </summary>
            <param name="dg"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.DataGridFilter.GetFilterEvaluationDelay(System.Windows.Controls.DataGrid)">
            <summary> Возвращает задержку, которая используется для изменения фильтра дроссельной заслонки до применения фильтра. </summary>
            <requires csharp="obj != null" vb="obj &lt;&gt; Nothing">obj != null</requires>
            <param name="dg"></param>
            <returns> Задержка дроссельной заслонки </returns>
        </member>
        <member name="T:IT.WPF.Filters.IFilterManager">
            <summary> Управляет фильтрацией и визуализацией фильтров всех колонок </summary>
        </member>
        <member name="P:IT.WPF.Filters.IFilterManager.FilterEnabled">
            <summary> Признак включенной фильтрации </summary>
        </member>
        <member name="P:IT.WPF.Filters.IFilterManager.FilterFactory">
            <summary> Предоставляет фабрику фильтров содержимого. </summary>
        </member>
        <member name="P:IT.WPF.Filters.IFilterManager.ItemsSource">
            <summary> Данные расширяемого контрола </summary>
        </member>
        <member name="P:IT.WPF.Filters.IFilterManager.Items">
            <summary> Данные расширяемого контрола </summary>
        </member>
        <member name="M:IT.WPF.Filters.IFilterManager.AddColumn(IT.WPF.IFilterHeaderControl)">
            <summary> Добавляет новый столбец. </summary>
            <param name="filterColumn"></param>
        </member>
        <member name="M:IT.WPF.Filters.IFilterManager.RemoveColumn(IT.WPF.IFilterHeaderControl)">
            <summary> Удаляет разгруженный столбец. </summary>
            <requires csharp="filterColumn != null" vb="filterColumn &lt;&gt; Nothing">filterColumn != null</requires>
        </member>
        <member name="M:IT.WPF.Filters.IFilterManager.OnFilterChanged">
            <summary> Уведомляет об изменении какого-либо фильтра </summary>
        </member>
        <member name="T:IT.WPF.Filters.FilterCore`1">
            <summary> Управляет фильтрацией и визуализацией фильтров всех колонок </summary>
        </member>
        <member name="P:IT.WPF.Filters.FilterCore`1.DefaultFilterFactory">
            <summary> Предоставляет фабрику фильтров содержимого по умолчанию (SimpleContentFilterFactory). </summary>
        </member>
        <member name="P:IT.WPF.Filters.FilterCore`1.IsWorking">
            <summary> Признак процесса фильтрации </summary>
        </member>
        <member name="P:IT.WPF.Filters.FilterCore`1.FilterEnabled">
            <summary> Признак включенной фильтрации </summary>
        </member>
        <member name="P:IT.WPF.Filters.FilterCore`1.FilterFactory">
            <summary> Предоставляет фабрику фильтров содержимого. </summary>
        </member>
        <member name="M:IT.WPF.Filters.FilterCore`1.OnFilterChanged">
            <summary> Уведомляет об изменении какого-либо фильтра </summary>
        </member>
        <member name="P:IT.WPF.Filters.FilterCore`1.FilterVisibility">
            <summary>
            представление фильтров
            </summary>
        </member>
        <member name="P:IT.WPF.Filters.FilterCore`1.ItemsControl">
            <summary> Списочный элемкнт управления, в котором применяется фмльтр (DataGrid, List, ListView etc ...) </summary>
        </member>
        <member name="F:IT.WPF.Filters.FilterCore`1._filterHeaderControls">
            <summary> Заголовки фильтра, появляются при инициализации DataGridFilterHeader</summary>
        </member>
        <member name="M:IT.WPF.Filters.FilterCore`1.#ctor(`0)">
            <summary> .ctor </summary>
            <param name="itemsControl"></param>
        </member>
        <member name="M:IT.WPF.Filters.FilterCore`1.Enable(IT.WPF.Filters.DataGridFilters)">
            <summary> Включение/отключение фильтрации + изменение видимости фильтров </summary>
            <param name="value"></param>
        </member>
        <member name="M:IT.WPF.Filters.FilterCore`1.GetColumnFilters(IT.WPF.IFilterHeaderControl[])">
            <summary> получение колонок, участвующих в фильтрации </summary>
            <param name="excluded"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.Filters.FilterCore`1.CreatePredicate(System.Collections.Generic.IEnumerable{IT.WPF.IFilterHeaderControl})">
            <summary> Создание условия фильтрации по заданным фильтрам </summary>
            <param name="columnFilters"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.Filters.FilterCore`1.EvaluateFilter">
            <summary> Вычисляет текущие фильтры и применяет фильтрацию к представлению коллекции элемента управления элемента. </summary>
        </member>
        <member name="T:IT.WPF.Filters.DataGridFilterCore">
            <summary>
            Управляет фильтрацией и визуализацией фильтров всех колонок
            </summary>
            <invariant>_dataGrid != null</invariant>
            <invariant>_filterColumnControls != null</invariant>
        </member>
        <member name="F:IT.WPF.Filters.DataGridFilterCore._deferFilterEvaluationTimer">
            <summary> Таймер задежки применения фильтра до тех пор, пока пользователь не перестанет печатать. </summary>
        </member>
        <member name="F:IT.WPF.Filters.DataGridFilterCore._globalFilter">
            <summary> Глобальный фильтр, который применяется в дополнение к фильтрам столбцов. </summary>
        </member>
        <member name="M:IT.WPF.Filters.DataGridFilterCore.#ctor(System.Windows.Controls.DataGrid)">
            <summary> .ctor </summary>
            <param name="dg"></param>
        </member>
        <member name="M:IT.WPF.Filters.DataGridFilterCore.Enable(IT.WPF.Filters.DataGridFilters)">
            <summary> Включение/отключение фильтрации </summary>
            <param name="value"></param>
        </member>
        <member name="M:IT.WPF.Filters.DataGridFilterCore.OnFilterChanged">
            <summary>
            Когда какое-либо условие фильтра изменилось, перезапустите таймер оценки, чтобы отложить оценку до тех пор, пока пользователь не перестанет печатать.
            </summary>
        </member>
        <member name="M:IT.WPF.Filters.DataGridFilterCore.CreatePredicate(System.Collections.Generic.IEnumerable{IT.WPF.IFilterHeaderControl})">
            <summary> Создание условия фильтрации по заданным фильтрам </summary>
            <param name="columnFilters"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.Filters.DataGridFilterCore.EvaluateFilter">
            <summary> Evaluates the current filters and applies the filtering to the collection view of the items control. </summary>
        </member>
        <member name="T:IT.WPF.Filters.DataGridFilters">
            <summary>
            Типы фильтров
            </summary>
        </member>
        <member name="F:IT.WPF.Filters.DataGridFilters.Disabled">
            <summary>
            отключен
            </summary>
        </member>
        <member name="F:IT.WPF.Filters.DataGridFilters.ComboBox">
            <summary>
            как в excel
            </summary>
        </member>
        <member name="F:IT.WPF.Filters.DataGridFilters.TextBoxContains">
            <summary>
            JetBrains
            </summary>
        </member>
        <member name="T:IT.WPF.Filters.IContentFilter">
            <summary>Интерфейс для фильтрации содезжимого (Content)</summary>
        </member>
        <member name="M:IT.WPF.Filters.IContentFilter.IsMatch(System.Object)">
            <summary>
            Determines whether the specified value matches the condition of this filter.
            </summary>
            <param name="value">The content.</param>
            <returns>
            <c>true</c> if the specified value matches the condition; otherwise, <c>false</c>.
                </returns>
        </member>
        <member name="T:IT.WPF.Filters.ContentFilterContains">
            <summary>
            A content filter using a simple "contains" string comparison to match the content and the value.
            </summary>
            <invariant>_content != null</invariant>
        </member>
        <member name="M:IT.WPF.Filters.ContentFilterContains.#ctor(System.String,System.StringComparison)">
            <summary>
            Initializes a new instance of the <see cref="T:DataGridExtensions.SimpleContentFilter" /> class.
            </summary>
            <param name="content">The content.</param>
            <param name="stringComparison">The string comparison.</param>
            <requires csharp="content != null" vb="content &lt;&gt; Nothing">content != null</requires>
        </member>
        <member name="M:IT.WPF.Filters.ContentFilterContains.IsMatch(System.Object)">
            <summary>
            Determines whether the specified value matches the condition of this filter.
            </summary>
            <param name="value">The content.</param>
            <returns>
            <c>true</c> if the specified value matches the condition; otherwise, <c>false</c>.
                </returns>
        </member>
        <member name="T:IT.WPF.Filters.ContentFilterEquals">
            <summary>
            IContentFilter использующий точное совпадение значений
            </summary>
        </member>
        <member name="M:IT.WPF.Filters.ContentFilterEquals.#ctor(System.String,System.StringComparison)">
            <summary>
            Initializes a new instance of the <see cref="T:DataGridExtensions.SimpleContentFilter" /> class.
            </summary>
            <param name="content">The content.</param>
            <param name="stringComparison">The string comparison.</param>
            <requires csharp="content != null" vb="content &lt;&gt; Nothing">content != null</requires>
        </member>
        <member name="M:IT.WPF.Filters.ContentFilterEquals.IsMatch(System.Object)">
            <summary>
            Determines whether the specified value matches the condition of this filter.
            </summary>
            <param name="value">The content.</param>
            <returns>
            <c>true</c> if the specified value matches the condition; otherwise, <c>false</c>.
                </returns>
        </member>
        <member name="T:IT.WPF.Filters.IContentFilterFactory">
            <summary>
            Фабрика фильтров контента
            </summary>
        </member>
        <member name="M:IT.WPF.Filters.IContentFilterFactory.Create(IT.WPF.Filters.DataGridFilters,System.Object)">
            <summary>
            получение фильтра
            </summary>
            <param name="filterType"></param>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="T:IT.WPF.Filters.SimpleContentFilterFactory">
            <summary> Factory to create a <see cref="T:IT.WPF.Filter.IContentFilter" /></summary>
        </member>
        <member name="P:IT.WPF.Filters.SimpleContentFilterFactory.StringComparison">
            <summary>Gets or sets the string comparison.</summary>
        </member>
        <member name="M:IT.WPF.Filters.SimpleContentFilterFactory.#ctor(System.StringComparison)">
            <summary> .ctor </summary>
            <param name="stringComparison">The string comparison to use.</param>
        </member>
        <member name="M:IT.WPF.Filters.SimpleContentFilterFactory.Create(IT.WPF.Filters.DataGridFilters,System.Object)">
            <summary> Создает фильтр содержимого для указанного содержимого. </summary>
            <param name="content">Содержимое для создания фильтра.</param>
            <param name="filterType">Тип фильтра</param>
            <returns>The new filter.</returns>
        </member>
        <member name="T:IT.WPF.IFilterHeaderControl">
            <summary>
            управление поведением конкретного фильтра
            </summary>
        </member>
        <member name="P:IT.WPF.IFilterHeaderControl.IsFiltered">
            <summary> Признак активного состояния фильтра </summary>
        </member>
        <member name="P:IT.WPF.IFilterHeaderControl.IsVisible">
            <summary> Видимость элемента фильтра </summary>
        </member>
        <member name="P:IT.WPF.IFilterHeaderControl.Visibility">
            <summary> Видимость элемента фильтра </summary>
        </member>
        <member name="M:IT.WPF.IFilterHeaderControl.Matches(System.Object)">
            <summary> Возвращает true, если данный элемент соответствует условию фильтра для этого столбца. </summary>
        </member>
        <member name="M:IT.WPF.IFilterHeaderControl.ValuesUpdated">
            <summary> Уведомление фильтра о том, что содержимое значений могло быть изменено. </summary>
        </member>
        <member name="T:IT.WPF.FilterHeaderControl">
            <summary>
            Элемент отображения фмльта
            </summary>
        </member>
        <member name="P:IT.WPF.FilterHeaderControl.NoFilterValue">
            <summary> Значение фильтра, которое отключает вильтрацию </summary>
        </member>
        <member name="F:IT.WPF.FilterHeaderControl.FilterProperty">
            <summary> Идентифицирует свойство зависимостей Filter (для привязки значений из UI) </summary>
        </member>
        <member name="P:IT.WPF.FilterHeaderControl.Filter">
            <summary>
            Предоставляемое пользователем значение фильтра (IFilter) или содержимое (обычно строка), используется для фильтрации этого столбца.
            Если объект фильтра реализует IFilter, он будет использоваться непосредственно как фильтр,
            иначе, значение будет использовано фильтром содержимого (IContentFilter).
            </summary>
        </member>
        <member name="E:IT.WPF.FilterHeaderControl.PropertyChanged">
            <summary> реализация INotifyPropertyChanged </summary>
        </member>
        <member name="M:IT.WPF.FilterHeaderControl.OnPropertyChanged(System.String)">
            <summary> реализация INotifyPropertyChanged </summary>
        </member>
        <member name="F:IT.WPF.FilterHeaderControl._cellValueProperty">
            <summary> Вспомогательное private свойство, используемое для вычисления пути свойства для элементов списка </summary>
        </member>
        <member name="P:IT.WPF.FilterHeaderControl.BindingProperty">
            <summary> Путь привязки </summary>
        </member>
        <member name="M:IT.WPF.FilterHeaderControl.GetItemContent(System.Object)">
            <summary>
            Изучает путь свойства и возвращает значение объекта для этого столбца.
            </summary>
        </member>
        <member name="P:IT.WPF.FilterHeaderControl.IsFiltered">
            <summary>
            Возвращает флаг, указывающий, имеет ли этот столбец какое-либо условие фильтра для оценки или нет.
            Если нет условия фильтра, нам не нужно вызывать этот фильтр.
            </summary>
        </member>
        <member name="P:IT.WPF.FilterHeaderControl.FilterHost">
            <summary> Менеджер фильтрации </summary>
        </member>
        <member name="F:IT.WPF.FilterHeaderControl._activeFilter">
            <summary> Активный фильтр для этого столбца.</summary>
        </member>
        <member name="M:IT.WPF.FilterHeaderControl.Matches(System.Object)">
            <summary> Возвращает true, если данный элемент соответствует условию фильтра для этого столбца. </summary>
        </member>
        <member name="M:IT.WPF.FilterHeaderControl.IT#WPF#IFilterHeaderControl#ValuesUpdated">
            <summary> Уведомление фильтра о том, что содержимое значений могло быть изменено. </summary>
        </member>
        <member name="P:IT.WPF.FilterHeaderControl.ItemsSource">
            <summary>
            Возвращает все уникальные исходные значения этого столбца в виде строки.
            Это может быть использовано, например, feed the ItemsSource в автоматическом фильтре, подобном Excel, который всегда отображает все исходные значения, которые можно выбрать.
            </summary>
        </member>
        <member name="P:IT.WPF.FilterHeaderControl.Values">
            <summary>
            Возвращает все уникальные видимые (отфильтрованные) значения этого столбца в виде строки.
            Это может быть использовано, например, отправьте файл ItemsSource для AutoCompleteBox, чтобы дать подсказку пользователю, что ввести.
            </summary>
            <remarks>
            Возможно, вам потребуется включить «NotifyOnTargetUpdated = true» в привязку DataGrid.ItemsSource для получения актуальных значений при изменении исходного объекта.
            </remarks>
        </member>
        <member name="P:IT.WPF.FilterHeaderControl.SourceValues">
            <summary>
            Возвращает все уникальные исходные значения этого столбца в виде строки.
            Это может быть использовано, например, feed the ItemsSource в автоматическом фильтре, подобном Excel, который всегда отображает все исходные значения, которые можно выбрать.
            </summary>
        </member>
        <member name="M:IT.WPF.FilterHeaderControl.InternalValues">
            <summary> Получает содержимое ячейки для всех элементов списка для этого столбца. </summary>
        </member>
        <member name="M:IT.WPF.FilterHeaderControl.InternalSourceValues">
            <summary> Получает содержимое ячейки для всех элементов списка для этого столбца. </summary>
        </member>
        <member name="M:IT.WPF.FilterHeaderControl.PrepareCombo(System.Collections.Generic.IEnumerable{System.String})">
            <summary> подготока значений для ComboBox </summary>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.FilterHeaderControl.CreateContentFilter(System.Object)">
            <summary> Создает новый фильтр содержимого. </summary>
        </member>
        <member name="T:IT.WPF.DataGridFilterHeader">
            <summary>
            Элемент отображения фмльта
            </summary>
        </member>
        <member name="P:IT.WPF.DataGridFilterHeader.BindingProperty">
            <summary>
            Фильтрация применяется к SortMemberPath, это путь, используемый для создания привязки.
            </summary>
        </member>
        <member name="P:IT.WPF.DataGridFilterHeader.ColumnHeader">
            <summary> Заголовок столбца, который мы фильтруем. Данный контрол внедряется в этот заголовок </summary>
        </member>
        <member name="P:IT.WPF.DataGridFilterHeader.DataGrid">
            <summary> Грид, который сожержит данный контрол </summary>
        </member>
        <member name="P:IT.WPF.DataGridFilterHeader.IsFiltered">
            <summary>
            Возвращает флаг, указывающий, имеет ли этот столбец какое-либо условие фильтра для оценки или нет.
            Если нет условия фильтра, нам не нужно вызывать этот фильтр.
            </summary>
        </member>
        <member name="M:IT.WPF.DataGridFilterHeader.#ctor">
            <summary> .ctor </summary>
        </member>
        <member name="T:IT.WPF.JetBrains.DataGridFilter">
            <summary>
            Defines the attached properties that can be set on the data grid level.
            </summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilter.IsAutoFilterEnabledProperty">
            <summary>Identifies the IsAutoFilterEnabled dependency property</summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilter.FilterProperty">
            <summary>
            Identifies the Filters dependency property.
            This property definition is private, so it's only accessible by code and can't be messed up by invalid bindings.
            </summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilter.ContentFilterFactoryProperty">
            <summary>Identifies the ContentFilterFactory dependency property</summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilter.FilterEvaluationDelayProperty">
            <summary>
            Identifies the FilterEvaluationDelay dependency property
            </summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilter.ResourceLocatorProperty">
            <summary>
            Identifies the <see cref="P:DataGridExtensions.DataGridFilter.ResourceLocator" /> attached property
            </summary>
            <AttachedPropertyComments>
              <summary>
                  Set an resource locator to locate resource if the component resource keys can not be found, e.g. because dgx is used in a plugin and multiple assemblies with resources might exist.
                  </summary>
            </AttachedPropertyComments>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilter.GlobalFilterProperty">
            <summary>
            Identifies the <see cref="P:DataGridExtensions.GlobalFilter" /> dependency property.
            </summary>
            <AttachedPropertyComments>
              <summary>
                  Allows to specify a global filter that is applied to the items in addition to the column filters.
                  </summary>
            </AttachedPropertyComments>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilter.TextColumnFilterTemplateKey">
            <summary> Template for the filter on a column represented by a DataGridTextColumn. </summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilter.CheckBoxColumnFilterTemplateKey">
            <summary> Template for the filter on a column represented by a DataGridCheckBoxColumn. </summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilter.TemplateColumnFilterTemplateKey">
            <summary> Template for the filter on a column represented by a DataGridCheckBoxColumn. </summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilter.ColumnHeaderTemplateKey">
            <summary>Template for the whole column header.</summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilter.IconTemplateKey">
            <summary>The filter icon template.</summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilter.IconStyleKey">
            <summary>The filter icon style.</summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilter.ColumnHeaderSearchCheckBoxStyleKey">
            <summary> Style for the filter check box in a filtered DataGridCheckBoxColumn. </summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilter.ColumnHeaderSearchTextBoxStyleKey">
            <summary> Style for the filter text box in a filtered DataGridTextColumn. </summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilter.ColumnHeaderSearchTextBoxClearButtonStyleKey">
            <summary> Style for the clear button in the filter text box in a filtered DataGridTextColumn. </summary>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilter.GetIsAutoFilterEnabled(System.Windows.Controls.DataGrid)">
            <summary> Gets if the default filters are automatically attached to each column. </summary>
            <requires csharp="obj != null" vb="obj &lt;&gt; Nothing">obj != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilter.SetIsAutoFilterEnabled(System.Windows.Controls.DataGrid,System.Boolean)">
            <summary>
            Sets if the default filters are automatically attached to each column. Set to false if you want to control filters by code.
            </summary>
            <requires csharp="obj != null" vb="obj &lt;&gt; Nothing">obj != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilter.GetFilter(System.Windows.Controls.DataGrid)">
            <summary>
            Filter attached property to attach the DataGridFilterHost instance to the owning DataGrid.
            This property is only used by code and is not accessible from XAML.
            </summary>
            <requires csharp="dataGrid != null" vb="dataGrid &lt;&gt; Nothing">dataGrid != null</requires>
            <ensures csharp="Contract.Result&lt;DataGridExtensions.DataGridFilterHost&gt;() != null" vb="Contract.Result(Of DataGridExtensions.DataGridFilterHost)() &lt;&gt; Nothing">result != null</ensures>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilter.GetContentFilterFactory(System.Windows.Controls.DataGrid)">
            <summary>
            Gets the content filter factory for the data grid filter.
            </summary>
            <requires csharp="dataGrid != null" vb="dataGrid &lt;&gt; Nothing">dataGrid != null</requires>
            <ensures csharp="Contract.Result&lt;DataGridExtensions.IContentFilterFactory&gt;() != null" vb="Contract.Result(Of DataGridExtensions.IContentFilterFactory)() &lt;&gt; Nothing">result != null</ensures>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilter.SetContentFilterFactory(System.Windows.Controls.DataGrid,IT.WPF.JetBrains.IContentFilterFactory)">
            <summary>
            Sets the content filter factory for the data grid filter.
            </summary>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilter.GetFilterEvaluationDelay(System.Windows.Controls.DataGrid)">
            <summary>
            Gets the delay that is used to throttle filter changes before the filter is applied.
            </summary>
            <param name="obj">The data grid</param>
            <returns>The throttle delay.</returns>
            <requires csharp="obj != null" vb="obj &lt;&gt; Nothing">obj != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilter.SetFilterEvaluationDelay(System.Windows.Controls.DataGrid,System.TimeSpan)">
            <summary>
            Sets the delay that is used to throttle filter changes before the filter is applied.
            </summary>
            <param name="obj">The data grid</param>
            <param name="value">The new throttle delay.</param>
            <requires csharp="obj != null" vb="obj &lt;&gt; Nothing">obj != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilter.GetResourceLocator(System.Windows.Controls.DataGrid)">
            <summary>Gets the resource locator.</summary>
            <param name="obj">The object.</param>
            <returns>The locator</returns>
            <requires csharp="obj != null" vb="obj &lt;&gt; Nothing">obj != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilter.SetResourceLocator(System.Windows.Controls.DataGrid,IT.WPF.JetBrains.IResourceLocator)">
            <summary>Sets the resource locator.</summary>
            <param name="obj">The object.</param>
            <param name="value">The value.</param>
            <requires csharp="obj != null" vb="obj &lt;&gt; Nothing">obj != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilter.GetGlobalFilter(System.Windows.Controls.DataGrid)">
            <summary>
            Gets the value of the <see cref="P:DataGridExtensions.GlobalFilter" /> attached property from a given <see cref="T:System.Windows.Controls.DataGrid" />.
            </summary>
            <param name="obj">The <see cref="T:System.Windows.Controls.DataGrid" /> from which to read the property value.</param>
            <returns>the value of the <see cref="P:DataGridExtensions.GlobalFilter" /> attached property.</returns>
            <requires csharp="obj != null" vb="obj &lt;&gt; Nothing">obj != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilter.SetGlobalFilter(System.Windows.Controls.DataGrid,System.Predicate{System.Object})">
            <summary>
            Sets the value of the <see cref="P:DataGridExtensions.GlobalFilter" /> attached property to a given <see cref="T:System.Windows.Controls.DataGrid" />.
            </summary>
            <param name="obj">The <see cref="T:System.Windows.Controls.DataGrid" /> on which to set the property value.</param>
            <param name="value">The property value to set.</param>
            <requires csharp="obj != null" vb="obj &lt;&gt; Nothing">obj != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilter.GlobalFilter_Changed(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <requires csharp="d != null" vb="d &lt;&gt; Nothing">d != null</requires>
        </member>
        <member name="T:IT.WPF.JetBrains.DataGridFilterColumn">
            <summary>
            Defines the attached properties that can be set on the data grid column level.
            </summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilterColumn.IsFilterVisibleProperty">
            <summary>Identifies the IsFilterVisible dependency property</summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilterColumn.TemplateProperty">
            <summary>Identifies the Template dependency property.</summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilterColumn.FilterProperty">
            <summary>Identifies the Filter dependency property</summary>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterColumn.GetIsFilterVisible(System.Windows.Controls.DataGridColumn)">
            <summary>Control the visibility of the filter for this column.</summary>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterColumn.SetIsFilterVisible(System.Windows.Controls.DataGridColumn,System.Boolean)">
            <summary>Control the visibility of the filter for this column.</summary>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterColumn.GetTemplate(System.Windows.Controls.DataGridColumn)">
            <summary>
            Gets the control template for the filter of this column. If the template is null or unset, a default template will be used.
            </summary>
            <requires csharp="column != null" vb="column &lt;&gt; Nothing">column != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterColumn.SetTemplate(System.Windows.Controls.DataGridColumn,System.Windows.Controls.ControlTemplate)">
            <summary>
            Sets the control template for the filter of this column. If the template is null or unset, a default template will be used.
            </summary>
            <requires csharp="column != null" vb="column &lt;&gt; Nothing">column != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterColumn.GetFilter(System.Windows.Controls.DataGridColumn)">
            <summary>Gets the filter expression of the column.</summary>
            <requires csharp="column != null" vb="column &lt;&gt; Nothing">column != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterColumn.SetFilter(System.Windows.Controls.DataGridColumn,System.Object)">
            <summary>Sets the filter expression of the column.</summary>
            <requires csharp="column != null" vb="column &lt;&gt; Nothing">column != null</requires>
        </member>
        <member name="T:IT.WPF.JetBrains.DataGridFilterColumnControl">
            <summary>
            This class is the control hosting all information needed for filtering of one column.
            Filtering is enabled by simply adding this control to the header template of the DataGridColumn.
            </summary>
            <seealso cref="T:System.Windows.Controls.Control" />
            <seealso cref="T:System.ComponentModel.INotifyPropertyChanged" />
            <invariant>(FilterHost == null) || (DataGrid != null)</invariant>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilterColumnControl.FilterProperty">
            <summary>Identifies the Filter dependency property</summary>
        </member>
        <member name="P:IT.WPF.JetBrains.DataGridFilterColumnControl.Filter">
            <summary>
            The user provided filter (IFilter) or content (usually a string) used to filter this column.
            If the filter object implements IFilter, it will be used directly as the filter,
            else the filter object will be passed to the content filter.
            </summary>
        </member>
        <member name="E:IT.WPF.JetBrains.DataGridFilterColumnControl.PropertyChanged">
            <summary>Occurs when a property value changes.</summary>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterColumnControl.OnPropertyChanged(System.String)">
            <summary>Raises the PropertyChanged event.</summary>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilterColumnControl._cellValueProperty">
            <summary>
            Identifies the CellValue dependency property, a private helper property used to evaluate the property path for the list items.
            </summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilterColumnControl._activeFilter">
            <summary>The active filter for this column.</summary>
        </member>
        <member name="P:IT.WPF.JetBrains.DataGridFilterColumnControl.ColumnHeader">
            <summary>
            The column header of the column we are filtering. This control must be a child element of the column header.
            </summary>
        </member>
        <member name="P:IT.WPF.JetBrains.DataGridFilterColumnControl.DataGrid">
            <summary>The DataGrid we belong to.</summary>
            <getter>
              <ensures csharp="this.FilterHost == default(decimal) || Contract.Result&lt;System.Windows.Controls.DataGrid&gt;() != null" vb="Me.FilterHost = Nothing OrElse Contract.Result(Of System.Windows.Controls.DataGrid)() &lt;&gt; Nothing">this.FilterHost == default(decimal) || result != null</ensures>
            </getter>
            <setter>
              <requires csharp="this.FilterHost == default(decimal) || value != null" vb="Me.FilterHost = Nothing OrElse value &lt;&gt; Nothing">this.FilterHost == default(decimal) || value != null</requires>
            </setter>
        </member>
        <member name="P:IT.WPF.JetBrains.DataGridFilterColumnControl.FilterHost">
            <summary>The filter we belong to.</summary>
            <getter>
              <ensures csharp="Contract.Result&lt;DataGridExtensions.DataGridFilterHost&gt;() == default(decimal) || this.DataGrid != null" vb="Contract.Result(Of DataGridExtensions.DataGridFilterHost)() = Nothing OrElse Me.DataGrid &lt;&gt; Nothing">result == default(decimal) || this.DataGrid != null</ensures>
            </getter>
            <setter>
              <requires csharp="value == default(decimal) || this.DataGrid != null" vb="value = Nothing OrElse Me.DataGrid &lt;&gt; Nothing">value == default(decimal) || this.DataGrid != null</requires>
            </setter>
        </member>
        <member name="P:IT.WPF.JetBrains.DataGridFilterColumnControl.IsFiltered">
            <summary>
            Returns a flag indicating whether this column has some filter condition to evaluate or not.
            If there is no filter condition we don't need to invoke this filter.
            </summary>
        </member>
        <member name="P:IT.WPF.JetBrains.DataGridFilterColumnControl.Values">
            <summary>
            Returns all distinct visible (filtered) values of this column as string.
            This can be used to e.g. feed the ItemsSource of an AutoCompleteBox to give a hint to the user what to enter.
            </summary>
            <remarks>
            You may need to include "NotifyOnTargetUpdated=true" in the binding of the DataGrid.ItemsSource to get up-to-date
            values when the source object changes.
            </remarks>
            <getter>
              <ensures csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;string&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of String))() &lt;&gt; Nothing">result != null</ensures>
            </getter>
        </member>
        <member name="P:IT.WPF.JetBrains.DataGridFilterColumnControl.SourceValues">
            <summary>
            Returns all distinct source values of this column as string.
            This can be used to e.g. feed the ItemsSource of an Excel-like auto-filter that always shows all source values that can be selected.
            </summary>
            <remarks>
            You may need to include "NotifyOnTargetUpdated=true" in the binding of the DataGrid.ItemsSource to get up-to-date
            values when the source object changes.
            </remarks>
            <getter>
              <ensures csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;string&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of String))() &lt;&gt; Nothing">result != null</ensures>
            </getter>
        </member>
        <member name="P:IT.WPF.JetBrains.DataGridFilterColumnControl.SelectableValues">
            <summary>
            Returns all distinct selectable values of this column as string.
            This can be used to e.g. feed the ItemsSource of an Excel-like auto-filter, that only shows the values that are currently selectable, depending on the other filters.
            </summary>
            <remarks>
            You may need to include "NotifyOnTargetUpdated=true" in the binding of the DataGrid.ItemsSource to get up-to-date
            values when the source object changes.
            </remarks>
            <getter>
              <ensures csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;string&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of String))() &lt;&gt; Nothing">result != null</ensures>
            </getter>
        </member>
        <member name="P:IT.WPF.JetBrains.DataGridFilterColumnControl.Column">
            <summary>Gets the column this control is hosting the filter for.</summary>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterColumnControl.#ctor">
            <inheritdoc />
            <summary>
            Initializes a new instance of the <see cref="T:DataGridExtensions.DataGridFilterColumnControl" /> class.
            </summary>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterColumnControl.Matches(System.Object)">
            <summary>
            Returns true if the given item matches the filter condition for this column.
            </summary>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterColumnControl.ValuesUpdated">
            <summary>
            Notification of the filter that the content of the values might have changed.
            </summary>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterColumnControl.GetCellContent(System.Object)">
            <summary>
            Examines the property path and returns the objects value for this column.
            Filtering is applied on the SortMemberPath, this is the path used to create the binding.
            </summary>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterColumnControl.InternalValues">
            <summary>
            Gets the cell content of all list items for this column.
            </summary>
            <ensures csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;string&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of String))() &lt;&gt; Nothing">result != null</ensures>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterColumnControl.InternalSourceValues(System.Predicate{System.Object})">
            <summary>
            Gets the cell content of all list items for this column.
            </summary>
            <requires csharp="new DataGridExtensions.DataGridFilterColumnControl.&lt;&gt;c__DisplayClass42_0(){&#xD;&#xA;    predicate = predicate, &#xD;&#xA;}.predicate != null" vb="(() =&gt; {&#xD;&#xA;    DataGridExtensions.DataGridFilterColumnControl.&lt;&gt;c__DisplayClass42_0 local_0_prime = New DataGridExtensions.DataGridFilterColumnControl.&lt;&gt;c__DisplayClass42_0();&#xD;&#xA;    (local_0_prime.predicate = predicate)&#xD;&#xA;    return local_0_prime; })().predicate &lt;&gt; Nothing">new DataGridExtensions.DataGridFilterColumnControl.&lt;&gt;c__DisplayClass42_0(){
                predicate = predicate,
            }.predicate != null</requires>
            <ensures csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;string&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of String))() &lt;&gt; Nothing">result != null</ensures>
        </member>
        <member name="T:IT.WPF.JetBrains.DataGridFilterHost">
            <summary>
            This class hosts all filter columns and handles the filter changes on the data grid level.
            This class will be attached to the DataGrid.
            </summary>
            <invariant>_dataGrid != null</invariant>
            <invariant>_filterColumnControls != null</invariant>
        </member>
        <member name="E:IT.WPF.JetBrains.DataGridFilterHost.Filtering">
            <summary>Occurs before new columns are filtered.</summary>
        </member>
        <member name="E:IT.WPF.JetBrains.DataGridFilterHost.FilterChanged">
            <summary>Occurs when any filter has changed.</summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilterHost._dataGrid">
            <summary>The data grid this filter is attached to.</summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilterHost._filterColumnControls">
            <summary>Filter information about each column.</summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilterHost._deferFilterEvaluationTimer">
            <summary> Timer to defer evaluation of the filter until user has stopped typing. </summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilterHost._isFilteringEnabled">
            <summary>Flag indicating if filtering is currently enabled.</summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilterHost._globalFilter">
            <summary> A global filter that is applied in addition to the column filters. </summary>
        </member>
        <member name="F:IT.WPF.JetBrains.DataGridFilterHost._filteredColumns">
            <summary>The columns that we are currently filtering.</summary>
        </member>
        <member name="P:IT.WPF.JetBrains.DataGridFilterHost.FilterColumnControls">
            <summary>
            Gets a the active filter column controls for this data grid.
            </summary>
            <getter>
              <ensures csharp="Contract.Result&lt;System.Collections.Generic.IList&lt;DataGridExtensions.DataGridFilterColumnControl&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IList(Of DataGridExtensions.DataGridFilterColumnControl))() &lt;&gt; Nothing">result != null</ensures>
            </getter>
        </member>
        <member name="P:IT.WPF.JetBrains.DataGridFilterHost.DataGrid">
            <summary>The data grid this filter is attached to.</summary>
            <getter>
              <ensures csharp="Contract.Result&lt;System.Windows.Controls.DataGrid&gt;() != null" vb="Contract.Result(Of System.Windows.Controls.DataGrid)() &lt;&gt; Nothing">result != null</ensures>
            </getter>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterHost.#ctor(System.Windows.Controls.DataGrid)">
            <summary>Create a new filter host for the given data grid.</summary>
            <param name="dataGrid">The data grid to filter.</param>
            <requires csharp="dataGrid != null" vb="dataGrid &lt;&gt; Nothing">dataGrid != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterHost.Clear">
            <summary>Clear all existing filter conditions.</summary>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterHost.Enable(System.Boolean)">
            <summary>
            Enables filtering by showing or hiding the filter controls.
            </summary>
            <param name="value">if set to <c>true</c>, filters controls are visible and filtering is enabled.</param>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterHost.OnFilterChanged">
            <summary>
            When any filter condition has changed restart the evaluation timer to defer
            the evaluation until the user has stopped typing.
            </summary>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterHost.AddColumn(IT.WPF.JetBrains.DataGridFilterColumnControl)">
            <summary>Adds a new column.</summary>
            <param name="filterColumn" />
            <requires csharp="filterColumn != null" vb="filterColumn &lt;&gt; Nothing">filterColumn != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterHost.RemoveColumn(IT.WPF.JetBrains.DataGridFilterColumnControl)">
            <summary>Removes an unloaded column.</summary>
            <requires csharp="filterColumn != null" vb="filterColumn &lt;&gt; Nothing">filterColumn != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterHost.CreateContentFilter(System.Object)">
            <summary>Creates a new content filter.</summary>
            <ensures csharp="Contract.Result&lt;DataGridExtensions.IContentFilter&gt;() != null" vb="Contract.Result(Of DataGridExtensions.IContentFilter)() &lt;&gt; Nothing">result != null</ensures>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilterHost.EvaluateFilter">
            <summary> Evaluates the current filters and applies the filtering to the collection view of the items control. </summary>
        </member>
        <member name="T:IT.WPF.JetBrains.DataGridFilteringEventArgs">
            <summary>
            Notification about additional columns to be filtered.
            Clients can e.g. use this event to cache/preload column data in a different thread and/or display a wait cursor while filtering.
            <remarks>
            Clients may only cancel the processing when e.g. the data grid is about to be unloaded. Canceling the process of filtering
            will cause the UI to be inconsistent.
            </remarks></summary>
        </member>
        <member name="P:IT.WPF.JetBrains.DataGridFilteringEventArgs.Columns">
            <summary>Gets the additional columns that will be filtered.</summary>
        </member>
        <member name="M:IT.WPF.JetBrains.DataGridFilteringEventArgs.#ctor(System.Collections.Generic.ICollection{System.Windows.Controls.DataGridColumn})">
            <inheritdoc />
            <summary>
            Initializes a new instance of the <see cref="T:DataGridExtensions.DataGridFilteringEventArgs" /> class.
            </summary>
            <param name="columns">The additional columns that will be filtered.</param>
        </member>
        <member name="T:IT.WPF.JetBrains.IContentFilter">
            <summary>Interface to be implemented by content filters.</summary>
        </member>
        <member name="M:IT.WPF.JetBrains.IContentFilter.IsMatch(System.Object)">
            <summary>
            Determines whether the specified value matches the condition of this filter.
            </summary>
            <param name="value">The content.</param>
            <returns>
            <c>true</c> if the specified value matches the condition; otherwise, <c>false</c>.
                </returns>
        </member>
        <member name="T:IT.WPF.JetBrains.IContentFilterFactory">
            <summary>
            Interface to be implemented by a content filter factory.
            </summary>
        </member>
        <member name="M:IT.WPF.JetBrains.IContentFilterFactory.Create(System.Object)">
            <summary>Creates the content filter for the specified content.</summary>
            <param name="content">The content to create the filter for.</param>
            <returns>The new filter.</returns>
            <ensures csharp="Contract.Result&lt;DataGridExtensions.IContentFilter&gt;() != null" vb="Contract.Result(Of DataGridExtensions.IContentFilter)() &lt;&gt; Nothing">result != null</ensures>
        </member>
        <member name="M:IT.WPF.JetBrains.InternalExtensionMethods.Restart(System.Windows.Threading.DispatcherTimer)">
            <summary>Restarts the specified timer.</summary>
            <param name="timer">The timer.</param>
            <requires csharp="timer != null" vb="timer &lt;&gt; Nothing">timer != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.InternalExtensionMethods.FindAncestorOrSelf``1(System.Windows.DependencyObject)">
            <summary>
            Walks the elements tree and returns the first element that derives from T.
            </summary>
            <typeparam name="T">The type to return.</typeparam>
            <param name="item">The item to start search with.</param>
            <returns>The element if found; otherwise null.</returns>
        </member>
        <member name="M:IT.WPF.JetBrains.InternalExtensionMethods.BeginInvoke(System.Windows.Media.Visual,System.Action)">
            <summary>
            Shortcut to <see cref="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])" /></summary>
            <requires csharp="self != null" vb="self &lt;&gt; Nothing">self != null</requires>
            <requires csharp="action != null" vb="action &lt;&gt; Nothing">action != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.InternalExtensionMethods.BeginInvoke(System.Windows.Media.Visual,System.Windows.Threading.DispatcherPriority,System.Action)">
            <summary>
            Shortcut to <see cref="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" /></summary>
            <requires csharp="self != null" vb="self &lt;&gt; Nothing">self != null</requires>
            <requires csharp="action != null" vb="action &lt;&gt; Nothing">action != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.InternalExtensionMethods.SafeCast``1(System.Object)">
            <summary>
            Performs a cast from object to <typeparamref name="T" />, avoiding possible null violations if <typeparamref name="T" /> is a value type.
            </summary>
            <typeparam name="T">The target type</typeparam>
            <param name="value">The value.</param>
            <returns>The value casted to <typeparamref name="T" />, or <c>default(T)</c> if value is <c>null</c>.</returns>
        </member>
        <member name="M:IT.WPF.JetBrains.InternalExtensionMethods.GetValue``1(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
            <summary>
            Gets the value of a dependency property using <see cref="M:DataGridExtensions.InternalExtensionMethods.SafeCast``1(System.Object)" />.
            </summary>
            <typeparam name="T" />
            <param name="self">The dependency object from which to get the value.</param>
            <param name="property">The property to get.</param>
            <returns>The value safely casted to <typeparamref name="T" /></returns>
            <requires csharp="self != null" vb="self &lt;&gt; Nothing">self != null</requires>
            <requires csharp="property != null" vb="property &lt;&gt; Nothing">property != null</requires>
        </member>
        <member name="T:IT.WPF.JetBrains.IResourceLocator">
            <summary>
            A resource locator to override the windows internal mechanism of resource loading, e.g. because dgx is used in a plugin and multiple assemblies with resources might exist.
            </summary>
        </member>
        <member name="M:IT.WPF.JetBrains.IResourceLocator.FindResource(System.Windows.FrameworkElement,System.Object)">
            <summary>Returns the resource for the specified resource key.</summary>
            <param name="target">The target object</param>
            <param name="resourceKey">The resource key.</param>
            <returns>The resource.</returns>
        </member>
        <member name="T:IT.WPF.JetBrains.SimpleContentFilter">
            <summary>
            A content filter using a simple "contains" string comparison to match the content and the value.
            </summary>
            <invariant>_content != null</invariant>
        </member>
        <member name="M:IT.WPF.JetBrains.SimpleContentFilter.#ctor(System.String,System.StringComparison)">
            <summary>
            Initializes a new instance of the <see cref="T:DataGridExtensions.SimpleContentFilter" /> class.
            </summary>
            <param name="content">The content.</param>
            <param name="stringComparison">The string comparison.</param>
            <requires csharp="content != null" vb="content &lt;&gt; Nothing">content != null</requires>
        </member>
        <member name="M:IT.WPF.JetBrains.SimpleContentFilter.IsMatch(System.Object)">
            <summary>
            Determines whether the specified value matches the condition of this filter.
            </summary>
            <param name="value">The content.</param>
            <returns>
            <c>true</c> if the specified value matches the condition; otherwise, <c>false</c>.
                </returns>
        </member>
        <member name="T:IT.WPF.JetBrains.SimpleContentFilterFactory">
            <summary>
            Factory to create a <see cref="T:DataGridExtensions.SimpleContentFilter" /></summary>
        </member>
        <member name="P:IT.WPF.JetBrains.SimpleContentFilterFactory.StringComparison">
            <summary>Gets or sets the string comparison.</summary>
        </member>
        <member name="M:IT.WPF.JetBrains.SimpleContentFilterFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DataGridExtensions.SimpleContentFilterFactory" /> class.
            </summary>
        </member>
        <member name="M:IT.WPF.JetBrains.SimpleContentFilterFactory.#ctor(System.StringComparison)">
            <summary>
            Initializes a new instance of the <see cref="T:DataGridExtensions.SimpleContentFilterFactory" /> class.
            </summary>
            <param name="stringComparison">The string comparison to use.</param>
        </member>
        <member name="M:IT.WPF.JetBrains.SimpleContentFilterFactory.Create(System.Object)">
            <summary>Creates the content filter for the specified content.</summary>
            <param name="content">The content to create the filter for.</param>
            <returns>The new filter.</returns>
            <ensures inheritedFrom="M:DataGridExtensions.IContentFilterFactory.Create(System.Object)" inheritedFromTypeName="IContentFilterFactory" csharp="Contract.Result&lt;DataGridExtensions.IContentFilter&gt;() != null" vb="Contract.Result(Of DataGridExtensions.IContentFilter)() &lt;&gt; Nothing">result != null</ensures>
        </member>
        <member name="T:IT.WPF.ValueWrapper`1">
            <summary>
            Обертка для удобного манипулирования объектами в списочных элементах управления
            </summary>
            <typeparam name="T">Тип перечисления</typeparam>
        </member>
        <member name="E:IT.WPF.ValueWrapper`1.IsCheckedChanged">
            <summary>
            No Coment
            </summary>
        </member>
        <member name="M:IT.WPF.ValueWrapper`1.Set_IsChecked(System.Boolean)">
            <summary>
            Метод установки значения + вызов события
            </summary>
            <param name="value"></param>
        </member>
        <member name="E:IT.WPF.ValueWrapper`1.IsEnabledChanged">
            <summary>
            No Coment
            </summary>
        </member>
        <member name="M:IT.WPF.ValueWrapper`1.Set_IsEnabled(System.Boolean)">
            <summary>
            Метод установки значения + вызов события
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:IT.WPF.ValueWrapper`1.Key">
            <summary>
            Собственно значение
            </summary>
        </member>
        <member name="P:IT.WPF.ValueWrapper`1.Caption">
            <summary>
            return this.ToString();
            </summary>
        </member>
        <member name="P:IT.WPF.ValueWrapper`1.IsChecked">
            <summary>
            Для возможности выбирать в списке
            </summary>
        </member>
        <member name="P:IT.WPF.ValueWrapper`1.IsEnabled">
            <summary>
            Для возможности отключения
            </summary>
        </member>
        <member name="M:IT.WPF.ValueWrapper`1.#ctor(`0,System.String,System.EventHandler{IT.EventArgs{System.Boolean}})">
            <summary>
            Конструктор
            </summary>
            <param name="key"></param>
            <param name="caption"></param>
            <param name="isCheckedChanged"></param>
        </member>
        <member name="M:IT.WPF.ValueWrapper`1.ToString">
            <summary>
            No Coment
            </summary>
            <returns></returns>
        </member>
        <member name="T:IT.WPF.EnumWrapper`1">
            <summary>
            Обертка для удобного использования Enum со списками
            </summary>
            <typeparam name="T">Тип перечисления</typeparam>
        </member>
        <member name="M:IT.WPF.EnumWrapper`1.CreateFromEnumType">
            <summary>
            return Enum.GetValues(typeof(T)).Cast&lt;T>().Select(i => new EnumWrapper&lt;T>(i));
            </summary>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.EnumWrapper`1.CreateFromEnumType(System.EventHandler{IT.EventArgs{System.Boolean}})">
            <summary>
            return Enum.GetValues(typeof(T)).Cast&lt;T>().Select(i => new EnumWrapper&lt;T>(i, isCheckedChanged));
            </summary>
            <param name="isCheckedChanged"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.EnumWrapper`1.#ctor(`0,System.EventHandler{IT.EventArgs{System.Boolean}})">
            <summary>
            Конструктор
            </summary>
            <param name="key"></param>
            <param name="isCheckedChanged"></param>
        </member>
        <member name="M:IT.WPF.EnumWrapper`1.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.EnumWrapper`1.GetHashCode">
            <summary>
            Возвращает хеш-код данного экземпляра
            </summary>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.EnumWrapper`1.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:IT.WPF.GroupCheckAdapter`1">
            <summary>
            Класс для управления группой переключателей
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="E:IT.WPF.GroupCheckAdapter`1.ValueChanged">
            <summary>
            Возникает при изменении какого-либо переключателя
            </summary>
        </member>
        <member name="M:IT.WPF.GroupCheckAdapter`1.OnValueChanged(IT.WPF.ValueWrapper{`0})">
            <summary>
            Вызывает соответствующее событие
            </summary>
            <param name="value">Изменившийся переключатель</param>
        </member>
        <member name="P:IT.WPF.GroupCheckAdapter`1.List">
            <summary>
            Весь список переключателей
            </summary>
        </member>
        <member name="P:IT.WPF.GroupCheckAdapter`1.Selected">
            <summary>
            Выбранные переключатели
            </summary>
        </member>
        <member name="M:IT.WPF.GroupCheckAdapter`1.#ctor(IT.WPF.ValueWrapper{`0}[],System.EventHandler{IT.EventArgs{IT.WPF.ValueWrapper{`0}}})">
            <summary>
            ctor
            </summary>
            <param name="fullArray">Весь список переключателей</param>
            <param name="onValueChanged">Вызывает соответствующее событие</param>
        </member>
        <member name="M:IT.WPF.GroupCheckAdapter`1.#ctor(System.Func{IT.WPF.ValueWrapper{`0}[]},System.EventHandler{IT.EventArgs{IT.WPF.ValueWrapper{`0}}})">
            <summary>
            ctor
            </summary>
            <param name="getFullArray">Метод получения списка переключателей</param>
            <param name="onValueChanged">Вызывает соответствующее событие</param>
        </member>
        <member name="M:IT.WPF.GroupCheckAdapter`1.Dispose(System.Boolean)">
            <summary>
            Деструктор, отвязывает события
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:IT.WPF.GroupCheckAdapter`1.Clear">
            <summary>
            Очистка значений переклюсателей
            </summary>
        </member>
        <member name="M:IT.WPF.GroupCheckAdapter`1.Reset(IT.WPF.ValueWrapper{`0}[])">
            <summary>
            Заново заполняет this.List
            </summary>
        </member>
        <member name="M:IT.WPF.GroupCheckAdapter`1.Reset">
            <summary>
            Заново заполняет (this.List = this.getFullArray())
            </summary>
        </member>
        <member name="M:IT.WPF.GroupCheckAdapter`1.Flag_Changed(System.Object,IT.EventArgs{System.Boolean})">
            <summary>
            Вызывается при смене состояния переключателя
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:IT.WPF.GroupCheckAdapter`1.Init_List">
            <summary>
            Привязка событий IsCheckedChanged для каждого элемента списка
            </summary>
        </member>
        <member name="T:IT.WPF.CommandBehavior">
            <summary>
            Defines the attached properties to create a CommandBehaviorBinding
            </summary>
        </member>
        <member name="F:IT.WPF.CommandBehavior.BehaviorProperty">
            <summary>
            Behavior Attached Dependency Property
            </summary>
        </member>
        <member name="M:IT.WPF.CommandBehavior.GetBehavior(System.Windows.DependencyObject)">
            <summary>
            Gets the Behavior property. 
            </summary>
        </member>
        <member name="M:IT.WPF.CommandBehavior.SetBehavior(System.Windows.DependencyObject,IT.WPF.CommandBehavior.CommandBehaviorBinding)">
            <summary>
            Sets the Behavior property.  
            </summary>
        </member>
        <member name="F:IT.WPF.CommandBehavior.CommandProperty">
            <summary>
            Command Attached Dependency Property
            </summary>
        </member>
        <member name="M:IT.WPF.CommandBehavior.GetCommand(System.Windows.DependencyObject)">
            <summary>
            Gets the Command property.  
            </summary>
        </member>
        <member name="M:IT.WPF.CommandBehavior.SetCommand(System.Windows.DependencyObject,System.Windows.Input.ICommand)">
            <summary>
            Sets the Command property. 
            </summary>
        </member>
        <member name="M:IT.WPF.CommandBehavior.OnCommandChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Одна из точек входа
            </summary>
        </member>
        <member name="F:IT.WPF.CommandBehavior.CommandParameterProperty">
            <summary>
            CommandParameter Attached Dependency Property
            </summary>
        </member>
        <member name="M:IT.WPF.CommandBehavior.GetCommandParameter(System.Windows.DependencyObject)">
            <summary>
            Gets the CommandParameter property.  
            </summary>
        </member>
        <member name="M:IT.WPF.CommandBehavior.SetCommandParameter(System.Windows.DependencyObject,System.Object)">
            <summary>
            Sets the CommandParameter property. 
            </summary>
        </member>
        <member name="M:IT.WPF.CommandBehavior.OnCommandParameterChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Одна из точек входа
            </summary>
        </member>
        <member name="F:IT.WPF.CommandBehavior.EventProperty">
            <summary>
            Event Attached Dependency Property
            </summary>
        </member>
        <member name="M:IT.WPF.CommandBehavior.GetEvent(System.Windows.DependencyObject)">
            <summary>
            Gets the Event property.  This dependency property 
            indicates ....
            </summary>
        </member>
        <member name="M:IT.WPF.CommandBehavior.SetEvent(System.Windows.DependencyObject,System.String)">
            <summary>
            Sets the Event property.  This dependency property 
            indicates ....
            </summary>
        </member>
        <member name="M:IT.WPF.CommandBehavior.OnEventChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Главная точка входа
            </summary>
        </member>
        <member name="T:IT.WPF.CommandBehavior.CommandBehaviorBinding">
            <summary>
            Defines the command behavior binding
            </summary>
        </member>
        <member name="P:IT.WPF.CommandBehavior.CommandBehaviorBinding.Owner">
            <summary>
            Get the owner of the CommandBinding ex: a Button
            This property can only be set from the BindEvent Method
            </summary>
        </member>
        <member name="P:IT.WPF.CommandBehavior.CommandBehaviorBinding.Command">
            <summary>
            The command to execute when the specified event is raised
            </summary>
        </member>
        <member name="P:IT.WPF.CommandBehavior.CommandBehaviorBinding.CommandParameter">
            <summary>
            Gets or sets a CommandParameter
            </summary>
        </member>
        <member name="P:IT.WPF.CommandBehavior.CommandBehaviorBinding.EventName">
            <summary>
            Имя события для подключения
            Это свойство может быть задано только из метода BindEvent
            </summary>
        </member>
        <member name="P:IT.WPF.CommandBehavior.CommandBehaviorBinding.Event">
            <summary>
            The event info of the event
            Для создания обработчика события
            </summary>
        </member>
        <member name="P:IT.WPF.CommandBehavior.CommandBehaviorBinding.EventHandler">
            <summary>
            Gets the EventHandler for the binding with the event
            Обработчик данного события
            </summary>
        </member>
        <member name="M:IT.WPF.CommandBehavior.CommandBehaviorBinding.ExecuteCommand2(System.EventArgs)">
            <summary>
            Выполняет комманду, если CommandParameter не указан, то передает EventArgs
            </summary>
        </member>
        <member name="M:IT.WPF.CommandBehavior.CommandBehaviorBinding.ExecuteCommand">
            <summary>
            Выполняет комманду
            </summary>
        </member>
        <member name="M:IT.WPF.CommandBehavior.CommandBehaviorBinding.Dispose">
            <summary>
            Unregisters the EventHandler from the Event
            </summary>
        </member>
        <member name="M:IT.WPF.CommandBehavior.CommandBehaviorBinding.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Object)">
            <summary>
            Generates a delegate with a matching signature of the supplied eventHandlerType
            This method only supports Events that have a delegate of type void
            </summary>
            <param name="eventHandlerType">тип делегата, который надо построить. Note that this must always be a void delegate</param>
            <param name="methodToInvoke">The method to invoke</param>
            <param name="methodInvoker">The object where the method resides</param>
            <returns>Returns a delegate with the same signature as eventHandlerType that calls the methodToInvoke inside</returns>
        </member>
        <member name="T:IT.WPF.DataGridBehaviour">
            <summary>
            Behaviour class for DataGrid
            </summary>
        </member>
        <member name="F:IT.WPF.DataGridBehaviour.ScrollToViewProperty">
            <summary>
            
            </summary>
        </member>
        <member name="M:IT.WPF.DataGridBehaviour.GetScrollToView(System.Windows.DependencyObject)">
            <summary>
            Retun current value of a ScrollToView
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.DataGridBehaviour.SetScrollToView(System.Windows.DependencyObject,System.Boolean)">
            <summary>
            Set the value of a ScrollToView
            </summary>
            <param name="element"></param>
            <param name="value"></param>
        </member>
        <member name="F:IT.WPF.DataGridBehaviour.SetKeyboardFocusOnScrollToViewProperty">
            <summary>
            
            </summary>
        </member>
        <member name="M:IT.WPF.DataGridBehaviour.GetSetKeyboardFocusOnScrollToView(System.Windows.DependencyObject)">
            <summary>
            Retun current value of a SetKeyboardFocusOnScrollToView
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.DataGridBehaviour.SetSetKeyboardFocusOnScrollToView(System.Windows.DependencyObject,System.Boolean)">
            <summary>
            Set the value of a SetKeyboardFocusOnScrollToView
            </summary>
            <param name="element"></param>
            <param name="value"></param>
        </member>
        <member name="F:IT.WPF.DataGridBehaviour.FilteredColumnsProperty">
            <summary>
            Фильтрация столбцов во атрибуту BrowsableAttribute, 
            для EnumDataTypeAttribute создает DataGridComboBoxColumn, 
            по атрибуту EditableAttribute определяется свойство IsReadOnly
            вытаскивание имени столбца из атрибутов DisplayAttribute и DisplayNameAttribute
            </summary>
        </member>
        <member name="M:IT.WPF.DataGridBehaviour.GetFilteredColumns(System.Windows.DependencyObject)">
            <summary>
            Retun current value of a FilteredColumns
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.DataGridBehaviour.SetFilteredColumns(System.Windows.DependencyObject,System.Boolean)">
            <summary>
            Set the value of a FilteredColumns
            </summary>
            <param name="element"></param>
            <param name="value"></param>
        </member>
        <member name="F:IT.WPF.DataGridBehaviour.ColumnsProperty">
            <summary>
            It allows you to bind a collection of columns
            </summary>
        </member>
        <member name="M:IT.WPF.DataGridBehaviour.GetColumns(System.Windows.DependencyObject)">
            <summary>
            Retun current value of a Columns
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.DataGridBehaviour.SetColumns(System.Windows.DependencyObject,System.Collections.ObjectModel.ObservableCollection{System.Windows.Controls.DataGridColumn})">
            <summary>
            Set the value of a Columns
            </summary>
            <param name="element"></param>
            <param name="value"></param>
        </member>
        <member name="T:IT.WPF.SelectorPropertyBase`1">
            <summary>
            Абстрактный Класс для удобной работы с выделением элементов ...
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="E:IT.WPF.SelectorPropertyBase`1.SelectedChanged">
            <summary>
            Возникает при изменении свойчтва
            </summary>
        </member>
        <member name="P:IT.WPF.SelectorPropertyBase`1.Inner_List">
            <summary>
            Список
            </summary>
        </member>
        <member name="P:IT.WPF.SelectorPropertyBase`1.SelectedItem">
            <summary>
            Текущее значение
            </summary>
        </member>
        <member name="M:IT.WPF.SelectorPropertyBase`1.SelectedItem_Set(`0,System.Boolean)">
            <summary>
            Устанавливает значение this._Current
            </summary>
            <param name="value">Значение</param>
            <param name="isRaiseEvent">Следует ли вызывать SelectedChanged</param>
        </member>
        <member name="P:IT.WPF.SelectorPropertyBase`1.HasSelected">
            <summary>
            Выбран ли какой-либо элемент в данный момент
            </summary>
        </member>
        <member name="M:IT.WPF.SelectorPropertyBase`1.#ctor">
            <summary>
            Constructor, only for heirs
            </summary>
        </member>
        <member name="M:IT.WPF.SelectorPropertyBase`1.#ctor(System.Action{`0})">
            <summary>
            constructor, only for heirs. Bind a method to an event
            </summary>
            <param name="selectedChanged">Метод, запускаемый при возникновении события</param>
        </member>
        <member name="M:IT.WPF.SelectorPropertyBase`1.Select(System.Func{`0,System.Boolean},System.Boolean,System.Boolean)">
            <summary>
            Поиск по списку
            </summary>
            <param name="pred">Услоаие поиска</param>
            <param name="changeCurrent">Следует ли заполнять результатом свойство Current</param>
            <param name="isRaiseEvent">Следует ли вызывать SelectedChanged</param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.SelectorPropertyBase`1.OnSelectedChanged(`0)">
            <summary>
            Вызов OnPropertyChanged("Current") и соответствующего события
            </summary>
            <param name="value">Выбор для передачи в событие</param>
        </member>
        <member name="T:IT.WPF.SelectorPropertyReadOnly`1">
            <summary>
            Класс для удобной работы с выделением элементов из константных списков
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:IT.WPF.SelectorPropertyReadOnly`1.Inner_List">
            <summary>
            Inner_List for SelectorPropertyBase
            </summary>
        </member>
        <member name="P:IT.WPF.SelectorPropertyReadOnly`1.ItemsSource">
            <summary>
            List
            </summary>
        </member>
        <member name="M:IT.WPF.SelectorPropertyReadOnly`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Action{`0})">
            <summary>
            Конструктор
            </summary>
            <param name="list"></param>
            <param name="onSelectedChanged"></param>
        </member>
        <member name="T:IT.WPF.SelectorProperty`2">
            <summary>
            class for easy work with lists in WPF
            </summary>
            <typeparam name="TList"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:IT.WPF.SelectorProperty`2.Inner_List">
            <summary>
            overrided abstract property Inner_List (for SelectorPropertyBase)
            </summary>
        </member>
        <member name="E:IT.WPF.SelectorProperty`2.ListChanged">
            <summary>
            Event
            </summary>
        </member>
        <member name="E:IT.WPF.SelectorProperty`2.IsWorkingChanged">
            <summary>
            Возникает при смене состояния IsWorking (используется только при асинхронных операциях)
            </summary>
        </member>
        <member name="F:IT.WPF.SelectorProperty`2.fGetList">
            <summary>
            Метод получения списка из конструктора
            </summary>
        </member>
        <member name="F:IT.WPF.SelectorProperty`2.fGetListAsync">
            <summary>
            Метод заполнения списка из конструктора
            </summary>
        </member>
        <member name="P:IT.WPF.SelectorProperty`2.List">
            <summary>
            Список
            </summary>
        </member>
        <member name="M:IT.WPF.SelectorProperty`2.List_Set(`0)">
            <summary>
            Проверка на отличие + Назначение list + запуск событий
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="P:IT.WPF.SelectorProperty`2.IsWorking">
            <summary>
            Признак работы в асинхронном режиме
            </summary>
        </member>
        <member name="M:IT.WPF.SelectorProperty`2.#ctor(System.Action{`1})">
            <summary>
            Конструктор
            </summary>
            <param name="selectedChanged">Подписчик соответствующего события</param>
        </member>
        <member name="M:IT.WPF.SelectorProperty`2.#ctor(`0,System.Action{`1})">
            <summary>
            Конструктор
            </summary>
            <param name="data">Функсия получения списка</param>
            <param name="selectedChanged">Подписчик соответствующего события</param>
        </member>
        <member name="M:IT.WPF.SelectorProperty`2.#ctor(System.Func{`0},System.Action{`1})">
            <summary>
            Конструктор
            </summary>
            <param name="getList">Функсия получения списка</param>
            <param name="selectedChanged">Подписчик соответствующего события</param>
        </member>
        <member name="M:IT.WPF.SelectorProperty`2.#ctor(System.Action{System.Action{`0}},System.Action{`1})">
            <summary>
            Конструктор
            </summary>
            <param name="getListAsync">Передает метод (типа SrtData()) для использования при готовности данных</param>
            <param name="selectedChanged">Подписчик соответствующего события</param>
        </member>
        <member name="M:IT.WPF.SelectorProperty`2.Reset(`0)">
            <summary>
            Сброс списка в указанное значение
            </summary>
            <param name="data">Данные для списка</param>
        </member>
        <member name="M:IT.WPF.SelectorProperty`2.Reset">
            <summary>
            Сброс списка, и принудительное заполнение из источника (из конструктора)
            </summary>
        </member>
        <member name="M:IT.WPF.SelectorProperty`2.ResetAsync">
            <summary>
            Сброс списка, и принудительное заполнение из источника (из конструктора) в другом потоке
            </summary>
        </member>
        <member name="M:IT.WPF.SelectorProperty`2.GetList_Internal">
            <summary>
            Создает список для поля List посредством вызова метод из конструктора
            </summary>
            <returns>Результат перегрузки с параметром от метода из конструктора</returns>
        </member>
        <member name="M:IT.WPF.SelectorProperty`2.OnListChanged(`0)">
            <summary>
            Вызов OnPropertyChanged("List") и соответствующего события
            </summary>
            <param name="list">Список для передачи в событие</param>
        </member>
        <member name="M:IT.WPF.SelectorProperty`2.OnIsWorkingChanged(System.Boolean)">
            <summary>
            Установка значения IsWorking и вызов сопутствующих методов
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:IT.WPF.SelectorProperty`1">
            <summary>
            Класс для удобной работы с выделением элементов списками с использованием IEnumerable<T/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:IT.WPF.SelectorProperty`1.#ctor(System.Func{System.Collections.Generic.IEnumerable{`0}},System.Action{`0})">
            <summary>
            constructor
            </summary>
            <param name="getList"></param>
            <param name="selectedChanged"></param>
        </member>
        <member name="T:IT.WPF.SelectorPropertyWPF`1">
            <summary>
            Класс для удобной работы с выделением элементов списками с использованием ObservableCollection<T/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:IT.WPF.SelectorPropertyWPF`1.#ctor(System.Action{`0})">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:IT.WPF.SelectorPropertyWPF`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Action{`0})">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:IT.WPF.SelectorPropertyWPF`1.#ctor(System.Func{System.Collections.ObjectModel.ObservableCollection{`0}},System.Action{`0})">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:IT.WPF.SelectorPropertyWPF`1.#ctor(System.Action{System.Action{System.Collections.ObjectModel.ObservableCollection{`0}}},System.Action{`0})">
            <summary>
            ctor
            </summary>
            <param name="fillListAsync"></param>
            <param name="onSelect"></param>
        </member>
        <member name="T:IT.WPF.MonitoredProperty`1">
            <summary>
            Класс-обертка для свойств, которай отслеживает изменение свойства
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="E:IT.WPF.MonitoredProperty`1.ValueChanged">
            <summary>
            Срабатывает при изменении значения
            </summary>
        </member>
        <member name="M:IT.WPF.MonitoredProperty`1.OnValueChanged(`0)">
            <summary>
            Вызывается после изменения свойства
            </summary>
            <param name="v">Новое значение</param>
        </member>
        <member name="P:IT.WPF.MonitoredProperty`1.Value">
            <summary>
            Значение свойства
            </summary>
        </member>
        <member name="M:IT.WPF.MonitoredProperty`1.#ctor(System.EventHandler{IT.EventArgs{`0}})">
            <summary>
            Конструктор
            </summary>
            <param name="valueChanged">Вызывается после изменения свойства</param>
        </member>
        <member name="M:IT.WPF.MonitoredProperty`1.#ctor(System.Action{`0})">
            <summary>
            Конструктор
            </summary>
            <param name="valueChanged">Вызывается после изменения свойства</param>
        </member>
        <member name="M:IT.WPF.MonitoredProperty`1.ToString">
            <summary>
            Вывод значения
            </summary>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.MonitoredProperty`1.op_Implicit(IT.WPF.MonitoredProperty{`0})~`0">
            <summary>
            Неявное преобразование данного класса в тип его значения (T Value)
            </summary>
            <param name="v"></param>
        </member>
        <member name="T:IT.WPF.VM_BaseInit">
            <summary>
            базовый класс для ViewModel, упрощает привязку команд к целевому View
            </summary>
        </member>
        <member name="P:IT.WPF.VM_BaseInit.IsDedug">
            <summary> Позволяет скрывать, используемые для отладки, визуальные компоненты </summary>
        </member>
        <member name="F:IT.WPF.VM_BaseInit.CurrentWindow">
            <summary> Окно, в котором находится привязанный View </summary>
        </member>
        <member name="F:IT.WPF.VM_BaseInit.CurrentUC">
            <summary> привязанный View </summary>
        </member>
        <member name="M:IT.WPF.VM_BaseInit.#ctor">
            <summary> .ctor </summary>
        </member>
        <member name="M:IT.WPF.VM_BaseInit.Init_Command_Core(System.Windows.Window)">
            <summary> Запускается в момент назначения данного ViewModel в качестве View.DataContext </summary>
            <param name="w">привязанный View</param>
        </member>
        <member name="M:IT.WPF.VM_BaseInit.Init_Command_Core(System.Windows.Controls.UserControl)">
            <summary> Запускается в момент назначения данного ViewModel в качестве View.DataContext </summary>
            <param name="uc">привязанный View</param>
        </member>
        <member name="M:IT.WPF.VM_BaseInit.Init_Command_Core(System.Windows.FrameworkElement)">
            <summary> Запускается в момент назначения данного ViewModel в качестве View.DataContext </summary>
            <param name="fe">привязанный View</param>
        </member>
        <member name="M:IT.WPF.VM_BaseInit.Init_Core">
            <summary>
            Для создания контролов. Так же запускает Init_Core_Async
            </summary>
        </member>
        <member name="M:IT.WPF.VM_BaseInit.Init_Core_Async">
            <summary>
            Для фоновой загрузки данных
            </summary>
        </member>
        <member name="M:IT.WPF.VM_BaseInit.MessageBoxShow(System.Windows.MessageBoxImage,System.String,System.Object[])">
            <summary>
            Облегченное использование MessageBox.Show()
            </summary>
            <param name="img">Иконка</param>
            <param name="formatStr">Строка форматирования</param>
            <param name="args">Параметры строки форматирования</param>
        </member>
        <member name="M:IT.WPF.VM_BaseInit.MessageBoxShow_Question(System.Windows.MessageBoxButton,System.String,System.Object[])">
            <summary>
            Облегченное использование MessageBox.Show()
            </summary>
            <param name="btn">Кнопки</param>
            <param name="formatStr">Строка форматирования</param>
            <param name="args">Параметры строки форматирования</param>
        </member>
        <member name="T:IT.WPF.WPF_Extentions">
            <summary>
            Методы расширения
            </summary>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.ShowDialog(System.Windows.Window,System.Object,System.Windows.Window,System.Boolean)">
            <summary>
            При отображении окна : 
            <para>1 задает ShowInTaskbar = false</para>
            <para>2 назначает Owner (если null, то Application.Current.MainWindow)</para>
            </summary>
            <param name="dialog">Расширяемый экземпляр</param>
            <param name="dataContext">Если не null, то присваивается dialog.DataContext</param>
            <param name="owner">Окно - владелец модального окна</param>
            <param name="showInTaskbar">Показывать ли окно в панели задач</param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.Add(System.Windows.Input.CommandBindingCollection,System.Windows.Input.ICommand,System.Windows.Input.ExecutedRoutedEventHandler,System.Windows.Input.CanExecuteRoutedEventHandler)">
            <summary>
            Добавление CommandBinding по его параметрам.
            Возвращает созданный CommandBinding
            </summary>
            <param name="cbs">Расширяемый объект</param>
            <param name="cmd">Комманда</param>
            <param name="exec">Метод спабатывания</param>
            <param name="canExec">Метод проверки доступности</param>
            <returns>Созданный CommandBinding</returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.Add(System.Windows.Input.CommandBindingCollection,System.Windows.Input.ICommand,System.Action{System.Windows.Input.ExecutedRoutedEventArgs},System.Action{System.Windows.Input.CanExecuteRoutedEventArgs})">
            <summary>
            Добавление CommandBinding по его параметрам.
            Возвращает созданный CommandBinding
            </summary>
            <param name="cbs">Расширяемый объект</param>
            <param name="cmd">Комманда</param>
            <param name="exec">Метод спабатывания</param>
            <param name="canExec">Метод проверки доступности</param>
            <returns>Созданный CommandBinding</returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.Add(System.Windows.Input.CommandBindingCollection,System.Windows.Input.ICommand,System.Action,System.Func{System.Boolean})">
            <summary>
            Добавление CommandBinding по его параметрам.
            Возвращает созданный CommandBinding
            </summary>
            <param name="cbs">Расширяемый объект</param>
            <param name="cmd">Комманда</param>
            <param name="exec">Метод спабатывания</param>
            <param name="canExec">Метод проверки доступности</param>
            <returns>Созданный CommandBinding</returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.Append(System.Windows.Input.CommandBindingCollection,System.Windows.Input.ICommand,System.Windows.Input.ExecutedRoutedEventHandler,System.Windows.Input.CanExecuteRoutedEventHandler)">
            <summary>
            Добавление CommandBinding по его параметрам.
            Возвращает созданный CommandBinding
            </summary>
            <param name="cbs">Расширяемый объект</param>
            <param name="cmd">Комманда</param>
            <param name="exec">Метод спабатывания</param>
            <param name="canExec">Метод проверки доступности</param>
            <returns>Созданный CommandBinding</returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.Append(System.Windows.Input.CommandBindingCollection,System.Windows.Input.ICommand,System.Action{System.Windows.Input.ExecutedRoutedEventArgs},System.Action{System.Windows.Input.CanExecuteRoutedEventArgs})">
            <summary>
            Добавление CommandBinding по его параметрам.
            Возвращает созданный CommandBinding
            </summary>
            <param name="cbs">Расширяемый объект</param>
            <param name="cmd">Комманда</param>
            <param name="exec">Метод спабатывания</param>
            <param name="canExec">Метод проверки доступности</param>
            <returns>Созданный CommandBinding</returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.ReAdd(System.Windows.Input.CommandBindingCollection,System.Windows.Input.ICommand,System.Windows.Input.ExecutedRoutedEventHandler,System.Windows.Input.CanExecuteRoutedEventHandler)">
            <summary>
            Добавление CommandBinding по его параметрам при этом удаляет существующие привязки к командам.
            Возвращает созданный CommandBinding
            </summary>
            <param name="cbs">Расширяемый объект</param>
            <param name="cmd">Комманда</param>
            <param name="exec">Метод спабатывания</param>
            <param name="canExec">Метод проверки доступности</param>
            <returns>Созданный CommandBinding</returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.ReAdd(System.Windows.Input.CommandBindingCollection,System.Windows.Input.ICommand,System.Action{System.Windows.Input.ExecutedRoutedEventArgs},System.Action{System.Windows.Input.CanExecuteRoutedEventArgs})">
            <summary>
            Добавление CommandBinding по его параметрам.
            Возвращает созданный CommandBinding
            </summary>
            <param name="cbs">Расширяемый объект</param>
            <param name="cmd">Комманда</param>
            <param name="exec">Метод спабатывания</param>
            <param name="canExec">Метод проверки доступности</param>
            <returns>Созданный CommandBinding</returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.GetCall(System.Windows.Controls.DataGrid,System.Object,System.Int32)">
            <summary>
            Получение ячейки
            </summary>
            <param name="dg"></param>
            <param name="item"></param>
            <param name="colIndex"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.Edit(System.Windows.Controls.DataGridCell,System.Predicate{System.Windows.FrameworkElement})">
            <summary>
            Переводит ячейку в режим редвктирования, предоставляет контрол режима редактирования. Возвращает успех редактирования
            </summary>
            <param name="cell"></param>
            <param name="editControl">Контрол режима редактирования (из GetCellContent())</param>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.EditCommit(System.Windows.Controls.DataGridCell,System.Predicate{System.Windows.FrameworkElement})">
            <summary>
            Переводит ячейку в режим редвктирования, предоставляет контрол режима редактирования. По окончании делает BindingGroup.CommitEdit() и выходит из режима редактирования; Возвращает успех редактирования
            </summary>
            <param name="cell"></param>
            <param name="editControl">Контрол режима редактирования (из GetCellContent())</param>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.GetFieldName(System.Windows.Controls.DataGridBoundColumn)">
            <summary>
            Пытается вернуть название поля привязки
            </summary>
            <param name="col"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.GetFieldName(System.Windows.Controls.Primitives.DataGridColumnHeader)">
            <summary>
            Пытается вернуть название поля привязки
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.GetFieldName(System.Windows.Controls.GridViewColumnHeader)">
            <summary>
            Пытается вернуть название поля привязки
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.GetVisualChildren``1(System.Windows.DependencyObject)">
            <summary>
            Получение дочерних визуальных объектов указанного типа
            </summary>
            <typeparam name="T"></typeparam>
            <param name="parent">Расширяемый объект</param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.GetVisualParent``1(System.Windows.DependencyObject)">
            <summary>
            Помск визуального родителя
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.SafeCast``1(System.Object,System.Boolean)">
            <summary>
            Performs a cast from object to <typeparamref name="T" />, avoiding possible null violations if <typeparamref name="T" /> is a value type.
            </summary>
            <typeparam name="T">The target type</typeparam>
            <param name="o">The value.</param>
            <param name="canReturnNull">The value.</param>
            <returns>The value casted to <typeparamref name="T" />, or <c>default(T)</c> if value is <c>null</c>.</returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.GetValue``1(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
            <summary> 
            Gets the value of a dependency property using <see cref="M:IT.WPF.WPF_Extentions.SafeCast``1(System.Object)" />.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <param name="dp"></param>
            <returns></returns>
        </member>
        <member name="M:IT.WPF.WPF_Extentions.ScrollToCenterOfView(System.Windows.Controls.ItemsControl,System.Object)">
            <summary>
            Прокрутка скрола
            </summary>
            <param name="itemsControl">Что прокрутить</param>
            <param name="item">Куда прокрутить</param>
        </member>
        <member name="T:IT.Other_Extentions">
            <summary>
            Расширения для простых типов
            </summary>
        </member>
        <member name="M:IT.Other_Extentions.AddRange(System.Collections.IList,System.Collections.IEnumerable)">
            <summary>
            No coment
            </summary>
            <param name="collection"></param>
            <param name="value"></param>
        </member>
        <member name="M:IT.Other_Extentions.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            No coment
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="value"></param>
        </member>
        <member name="M:IT.Other_Extentions.GetValue``1(System.Nullable{``0},``0)">
            <summary>
            При отсутствии значения возвращает def
            </summary>
            <typeparam name="T">Тип расширения</typeparam>
            <param name="obj">Расширяемый объект</param>
            <param name="def">Значение по умолчанию</param>
            <returns></returns>
        </member>
        <member name="M:IT.Other_Extentions.ClonePropertyTo(System.Object,System.Object,System.Boolean)">
            <summary>
            Пытается заполнить свойства переданного объекта собственными значениями соответствующих свойств
            используя PropertyInfo
            </summary>
            <param name="source">Расширяемый экземпляр</param>
            <param name="dest">Объект для заполнения соответствующих свойств</param>
            <param name="isIcgnoreCase">Параметр сравнения наименованй свойств</param>
            <returns>Объект с заполнеными соответствующими свойствами</returns>
        </member>
        <member name="T:IT.EnumExtention">
            <summary>
            расширения для перечислений
            </summary>
        </member>
        <member name="M:IT.EnumExtention.GetAttributeValue``2(System.Reflection.ICustomAttributeProvider,System.Func{``0,``1},``1)">
            <summary>
            Получение значения атрибута указанного типа
            </summary>
            <typeparam name="Tattr">Тип атрибута</typeparam>
            <typeparam name="R">Тип результата</typeparam>
            <param name="aPr">Расширяемый экземпляр</param>
            <param name="expression">Функция получения результата</param>
            <param name="defaultValue">Значение по умолчанию</param>
            <returns></returns>
        </member>
        <member name="M:IT.EnumExtention.GetAttributeValueStr``1(System.Reflection.ICustomAttributeProvider,System.Func{``0,System.String},System.String)">
            <summary>
            Получение строкового значения атрибута указанного типа
            </summary>
            <typeparam name="Tattr">Тип атрибута</typeparam>
            <param name="aPr">Расширяемый экземпляр</param>
            <param name="expression">Функция получения результата</param>
            <param name="defaultValue">Значение по умолчанию</param>
            <returns></returns>
        </member>
        <member name="M:IT.EnumExtention.GetNameFromAttributes(System.Reflection.ICustomAttributeProvider,System.String)">
            <summary>
            Попытка получить значения атрибутов : Display.Name, Display.ShortName, Display.Description, DisplayName.DisplayName, Description.Description
            </summary>
            <param name="aPr"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:IT.EnumExtention.ToArray(System.Enum)">
            <summary>
            Привычное преобразование перечисленя
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:IT.EnumExtention.GetAttributeValue``2(System.Enum,System.Func{``0,``1},``1)">
            <summary>
            Получение значения атрибута перечисления
            </summary>
            <typeparam name="Tattr">Тип атрибута</typeparam>
            <typeparam name="R">Тип результата</typeparam>
            <param name="enumValue">Расширяемый экземпляр</param>
            <param name="expression">Функция получения результата</param>
            <param name="defaultValue">Функция получения результата</param>
            <returns></returns>
        </member>
        <member name="M:IT.EnumExtention.GetDescription(System.Enum)">
            <summary>
            Получение значения атрибута DescriptionAttribute
            </summary>
            <param name="enumValue">Расширяемый экземпляр</param>
            <returns>Значение атрибута DescriptionAttribute</returns>
        </member>
        <member name="T:IT.ILog">
            <summary>
            Интерфейс для возможности расширения других классов методами логирования
            </summary>
        </member>
        <member name="T:IT.LogExtentions">
            <summary>
            Класс расширения методов логирования
            </summary>
        </member>
        <member name="M:IT.LogExtentions.LogFmt(IT.ILog,System.Diagnostics.TraceLevel,System.Exception,System.String,System.Object[])">
            <summary>
            Формирует сообщение
            </summary>
            <param name="obj"></param>
            <param name="level"></param>
            <param name="ex"></param>
            <param name="msg"></param>
            <param name="args">Аргументы метода</param>
            <returns></returns>
        </member>
        <member name="M:IT.LogExtentions.Error(IT.ILog,System.Exception,System.String,System.Object[])">
            <summary>
            Логирование соответствующего уровня
            </summary>
            <param name="obj"></param>
            <param name="ex"></param>
            <param name="msg"></param>
            <param name="args">Аргументы метода</param>
        </member>
        <member name="M:IT.LogExtentions.Error(IT.ILog,System.Exception,System.Object[])">
            <summary>
            Логирование соответствующего уровня
            </summary>
            <param name="obj"></param>
            <param name="ex"></param>
            <param name="args">Аргументы метода</param>
        </member>
        <member name="M:IT.LogExtentions.Warn(IT.ILog,System.Exception,System.String,System.Object[])">
            <summary>
            Логирование соответствующего уровня
            </summary>
            <param name="obj"></param>
            <param name="ex"></param>
            <param name="msg"></param>
            <param name="args">Аргументы метода</param>
        </member>
        <member name="M:IT.LogExtentions.Info(IT.ILog,System.String,System.Object[])">
            <summary>
            Логирование соответствующего уровня
            </summary>
            <param name="obj"></param>
            <param name="msg"></param>
            <param name="args">Аргументы метода</param>
        </member>
        <member name="M:IT.LogExtentions.Debug(IT.ILog,System.String,System.Object[])">
            <summary>
            Логирование соответствующего уровня
            </summary>
            <param name="obj"></param>
            <param name="msg"></param>
            <param name="args">Аргументы метода</param>
        </member>
        <member name="M:IT.LogExtentions.Trace(IT.ILog,System.String,System.Object[])">
            <summary>
            Логирование соответствующего уровня
            </summary>
            <param name="obj"></param>
            <param name="msg"></param>
            <param name="args">Аргументы метода</param>
        </member>
        <member name="T:IT.Contract">
            <summary>
            замена System.Diagnostics.Contracts
            </summary>
        </member>
        <member name="M:IT.Contract.Requires``1(System.Boolean,System.Object[])">
            <summary>
            замена System.Diagnostics.Contracts.Contract.Requires()
            if(!conditions) - создание исключения TException
            </summary>
            <typeparam name="TException">Тип мсключения, при негативном "conditions" </typeparam>
            <param name="conditions">Условие НЕ создания исключения</param>
            <param name="args">Параметры конструктора исключения "conditions"</param>
        </member>
        <member name="M:IT.Contract.Requires(System.Boolean,System.String)">
            <summary>
            замена System.Diagnostics.Contracts.Contract.Requires()
            if(!conditions) - создание исключения ArgumentException
            </summary>
            <param name="conditions">Условие НЕ создания исключения</param>
            <param name="msg">Параметр конструктора исключения "conditions"</param>
        </member>
        <member name="M:IT.Contract.NotIsNullOrEmpty(System.String,System.String)">
            <summary>
            NotNull(value, parameterName) + проверка на нулевую длину, при успехе вызывает ArgumentException("'{0}' не может быть пустой строкой")
            </summary>
            <param name="value"></param>
            <param name="parameterName"></param>
        </member>
        <member name="M:IT.Contract.NotNull(System.Object,System.String)">
            <summary>
            Проверка на null, при успехе вызывает ArgumentNullException
            </summary>
            <param name="value">Проверяемый параметр</param>
            <param name="parameterName">Имя параметра</param>
        </member>
        <member name="T:IT.ISettingsBase">
            <summary>
            
            </summary>
        </member>
        <member name="M:IT.ISettingsBase.GetValue(System.String)">
            <summary>
            Без коментариев, default = null
            </summary>
            <param name="key">Ключ параметра (можно null)</param>
            <returns></returns>
        </member>
        <member name="M:IT.ISettingsBase.GetConnectionStringSettings(System.String)">
            <summary>
            Получение ConnectionStringSettings с указанным ключем
            </summary>
            <param name="key">Ключ</param>
            <returns></returns>
        </member>
        <member name="T:IT.SettingsBase">
            <summary>
            Класс для облегчения управления настройками программы. 
            </summary>
        </member>
        <member name="F:IT.SettingsBase.valueCache">
            <summary>
            Кешированные значения ключей
            </summary>
        </member>
        <member name="M:IT.SettingsBase.GetValue(System.String)">
            <summary>
            Без коментариев, default = null
            </summary>
            <param name="key">Ключ параметра (можно null)</param>
            <returns></returns>
        </member>
        <member name="M:IT.SettingsBase.GetConnectionStringSettings(System.String)">
            <summary>
            Получение ConnectionStringSettings с указанным ключем
            </summary>
            <param name="key">Ключ</param>
            <returns></returns>
        </member>
        <member name="M:IT.SettingsBase.GetValueArray(System.String,System.String)">
            <summary>
            Получение массива значений из строки.
            Разделитель = new char[] { ';', '|', ' ', ',' }
            </summary>
            <param name="key">Ключ параметра (можно null)</param>
            <param name="defValue">Дефолтное значение</param>
            <returns></returns>
        </member>
        <member name="M:IT.SettingsBase.GetValueArray(System.String,System.Char[],System.String)">
            <summary>
            Получение массива значений из строки с указанными разделителями
            </summary>
            <param name="key">Ключ параметра (можно null)</param>
            <param name="separators">Разделитель значений</param>
            <param name="defValue">Дефолтное значение</param>
            <returns></returns>
        </member>
        <member name="M:IT.SettingsBase.GetValueInt(System.String,System.Int32)">
            <summary>
            Без коментариев, default = 0
            </summary>
        </member>
        <member name="M:IT.SettingsBase.GetValueBool(System.String,System.Boolean)">
            <summary>
            Без коментариев, default = false
            </summary>
        </member>
        <member name="M:IT.SettingsBase.GetConnectionString(System.String,System.String)">
            <summary>
            Получение свойства ConnectionString из ConnectionStringSettings с указанным ключем
            </summary>
            <param name="key">Ключ</param>
            <param name="defValue">Значение по умолчанию</param>
            <returns></returns>
        </member>
        <member name="T:IT.SettingsBase`1">
            <summary>
            Инкапсуляция свойства Def
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:IT.SettingsBase`1.Def">
            <summary>
            Гарантированный экземпляр
            </summary>
        </member>
        <member name="T:IT.SettingsBaseSaved">
            <summary>
            Класс для облегчения управления настройками программы. 
            <para>public static Settings Def { get { return _defaultInstancef ?? (_defaultInstancef = new Settings()); } }</para>
            <para>private static Settings _defaultInstancef = null;</para>
            </summary>
        </member>
        <member name="P:IT.SettingsBaseSaved.Cfg">
            <summary>
            Без коментариев
            </summary>
        </member>
        <member name="M:IT.SettingsBaseSaved.Init(System.Configuration.Configuration)">
            <summary>
            Для задания конфигурации из другого файла
            </summary>
            <param name="cfg">Новая конфигурация</param>
        </member>
        <member name="M:IT.SettingsBaseSaved.GetValue(System.String)">
            <summary>
            Без коментариев, default = null
            </summary>
            <param name="key">Ключ параметра (можно null)</param>
            <returns></returns>
        </member>
        <member name="M:IT.SettingsBaseSaved.GetConnectionStringSettings(System.String)">
            <summary>
            Получение ConnectionStringSettings с указанным ключем
            </summary>
            <param name="key">Ключ</param>
            <returns></returns>
        </member>
        <member name="M:IT.SettingsBaseSaved.SetValue(System.String,System.String)">
            <summary>
            Без коментариев
            </summary>
            <param name="key">Ключ параметра</param>
            <param name="value">Значение</param>
            <returns></returns>
        </member>
        <member name="M:IT.SettingsBaseSaved.Save(System.Configuration.ConfigurationSaveMode)">
            <summary>
            Без коментариев
            </summary>
        </member>
        <member name="T:IT.SettingsBaseSaved`1">
            <summary>
            Инкапсуляция свойства Def
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:IT.SettingsBaseSaved`1.Def">
            <summary>
            Гарантированный экземпляр
            </summary>
        </member>
        <member name="T:IT.EventArgs`1">
            <summary>
            Для передачи параметра типа T
            </summary>
        </member>
        <member name="P:IT.EventArgs`1.Value">
            <summary>
            Собственно параметр
            </summary>
        </member>
        <member name="M:IT.EventArgs`1.#ctor(`0)">
            <summary>
            Конструктор
            </summary>
            <param name="value">Передаваемый параметр</param>
        </member>
        <member name="T:IT.EventArgs`2">
            <summary>
            Для передачи параметра типа T1, T2
            </summary>
        </member>
        <member name="P:IT.EventArgs`2.Value1">
            <summary>
            Собственно параметр 1
            </summary>
        </member>
        <member name="P:IT.EventArgs`2.Value2">
            <summary>
            Собственно параметр 2
            </summary>
        </member>
        <member name="M:IT.EventArgs`2.#ctor(`0,`1)">
            <summary>
            Конструктор
            </summary>
            <param name="value1">Передаваемый параметр 1</param>
            <param name="value2">Передаваемый параметр 2</param>
        </member>
        <member name="T:IT.EventArgs`3">
            <summary>
            Для передачи параметра типа T1, T2
            </summary>
        </member>
        <member name="P:IT.EventArgs`3.Value3">
            <summary>
            Собственно параметр 2
            </summary>
        </member>
        <member name="M:IT.EventArgs`3.#ctor(`0,`1,`2)">
            <summary>
            Конструктор
            </summary>
            <param name="value1">Передаваемый параметр 1</param>
            <param name="value2">Передаваемый параметр 2</param>
            <param name="value3">Передаваемый параметр 2</param>
        </member>
        <member name="T:IT.TreeNode_Base">
            <summary>
            Заготовка для использования в деревьях (только базовые свойтва и события)
            </summary>
        </member>
        <member name="E:IT.TreeNode_Base.IsCheckedChanged">
            <summary>
            Срабатывает при выборе узла
            </summary>
        </member>
        <member name="E:IT.TreeNode_Base.IsExpandedChanged">
            <summary>
            Срабатывает при раскрытии узла
            </summary>
        </member>
        <member name="E:IT.TreeNode_Base.IsSelectedChanged">
            <summary>
            Срабатывает при выборе узла
            </summary>
        </member>
        <member name="P:IT.TreeNode_Base.IsChecked">
            <summary>
            Для возможности выбора
            </summary>
        </member>
        <member name="P:IT.TreeNode_Base.IsExpanded">
            <summary>
            Индикатор состояния узла (binding)
            </summary>
        </member>
        <member name="P:IT.TreeNode_Base.IsSelected">
            <summary>
            Индикатор состояния узла  (binding)
            </summary>
        </member>
        <member name="P:IT.TreeNode_Base.Image">
            <summary>
            Позволяет использовать картинку
            </summary>
        </member>
        <member name="M:IT.TreeNode_Base.SetIsChecked(System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            установка дочерних IsChecked, установка данного IsChecked, вызов IsCheckedChanged
            </summary>
            <param name="value"></param>
            <param name="isRiseEvent"></param>
        </member>
        <member name="M:IT.TreeNode_Base.SetIsExpanded(System.Boolean)">
            <summary>
            Позволяет переназначить действие при паскрытии узла
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:IT.TreeNode_Base.SetIsSelected(System.Boolean)">
            <summary>
            Позволяет переназначить действие при выборе узла
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:IT.TreeNode_Base.SetImage(System.Object)">
            <summary>
            Позволяет применить картинку
            </summary>
            <param name="image"></param>
        </member>
        <member name="T:IT.TreeNode_Base`1">
            <summary>
            Заготовка для использования в деревьях
            </summary>
            <typeparam name="TNode">Тип класса-наследника</typeparam>
        </member>
        <member name="M:IT.TreeNode_Base`1.SetIsCheckedByChilds(IT.TreeNode_Base{`0})">
            <summary>
            Вычисляет и устанавливает IsChecked в зависимости от состояния IsChecked дочерних элементов
            </summary>
            <param name="node"></param>
        </member>
        <member name="P:IT.TreeNode_Base`1.Parent">
            <summary>
            Родительский узел
            </summary>
        </member>
        <member name="P:IT.TreeNode_Base`1.Childs">
            <summary>
            Список дочерних узлов
            </summary>
        </member>
        <member name="P:IT.TreeNode_Base`1.Level">
            <summary>
            Уровень вложенности
            </summary>
        </member>
        <member name="M:IT.TreeNode_Base`1.#ctor(`0)">
            <summary>
            Конструктор
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:IT.TreeNode_Base`1.GetRoot">
            <summary>
            Получение верхнего узла данной ветки
            </summary>
            <returns></returns>
        </member>
        <member name="M:IT.TreeNode_Base`1.SetIsChecked(System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            установка дочерних IsCheckedб установка данного IsChecked, вызов IsCheckedChanged
            </summary>
            <param name="value"></param>
            <param name="isRiseEvent"></param>
        </member>
        <member name="M:IT.TreeNode_Base`1.SetIsSelected(System.Boolean)">
            <summary>
            Позволяет переназначить действие при выборе узла
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:IT.TreeNode_Base`1.ClearSelected">
            <summary>
            Очистка IsSelected данного узла и всех дочерних
            </summary>
        </member>
        <member name="M:IT.TreeNode_Base`1.CreateChilds">
            <summary>
            При переопределении в наследнике позволяет указать другой класс соллекции
            </summary>
            <returns></returns>
        </member>
        <member name="T:IT.TreeNode`2">
            <summary>
            Заготовка для использования в деревьях (в основном методы для работы с T)
            </summary>
            <typeparam name="TNode">Тип класса-наследника</typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:IT.TreeNode`2.Value">
            <summary>
            Значение узла
            </summary>
        </member>
        <member name="M:IT.TreeNode`2.#ctor(IT.TreeNode{`0,`1},`1)">
            <summary>
            Конструктор
            </summary>
            <param name="parent">Родительский узел</param>
            <param name="value">Значение узла</param>
        </member>
        <member name="M:IT.TreeNode`2.Add(`1)">
            <summary>
            Формирует + добавляет дочерний узел и возвращает его
            </summary>
            <param name="item">Значение нового узла</param>
            <returns></returns>
        </member>
        <member name="M:IT.TreeNode`2.CreateChild(`1)">
            <summary>
            Позволяет наследникам контрольровать процесс создания экземпляра
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:IT.TreeNode`2.Contains(`1)">
            <summary>
            Проверяет наличие значения в узле и всех дочерних узлах
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:IT.TreeNode`2.Find(System.Predicate{`0})">
            <summary>
            Поиск первого узла по критерию в узле и всех дочерних узлах
            </summary>
            <param name="criteria"></param>
            <returns></returns>
        </member>
        <member name="M:IT.TreeNode`2.FindListNode(System.Func{`0,System.Boolean})">
            <summary>
            Поиск всех узлов по критерию в узле и всех дочерних узлах
            </summary>
            <param name="criteria"></param>
            <returns></returns>
        </member>
        <member name="M:IT.TreeNode`2.ToString">
            <summary>
            Позволяет выводить дерево родителей + себя
            </summary>
            <returns></returns>
        </member>
        <member name="T:IT.Utils">
            <summary>
            Полезные утилиты
            </summary>
        </member>
        <member name="M:IT.Utils.CheckVersion(System.String,System.Version)">
            <summary>
            Сравнивает версию (диапазон версий) с верией клиента
            </summary>
            <param name="workingVersion"></param>
            <param name="clientVersion"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Utils.Execute(System.String,System.String,System.String)">
            <summary>
            Выполняет filePath из workDir с параметрами args
            </summary>
            <param name="filePath">Запускаемый файл</param>
            <param name="workDir">Рабочая папка (если надо)</param>
            <param name="args">Параметры командной строки (если надо)</param>
            <returns></returns>
        </member>
        <member name="M:IT.Utils.CreateComObject(System.String,System.String)">
            <summary>
            Пытается создать ActiveX объект по его appId
            </summary>
            <param name="appId">Зарегистрированное имя ActiveX</param>
            <param name="registerPath">Путь к файлу (.bat) регристрации ActiveX</param>
            <returns></returns>
        </member>
        <member name="M:IT.Utils.CreateBakFile(System.String)">
            <summary>
            Если файл присутствует, создает файл вида : [name]_bak[i].[ext] посредством увеличения [i]
            </summary>
            <param name="filePath">Проверяемый путь</param>
        </member>
        <member name="M:IT.Utils.Encrypt(System.String)">
            <summary>
            Шифрует параметры запуска для программ "Центра запуска"
            </summary>
            <param name="InString"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Utils.Decrypt(System.String@)">
            <summary>
            Дешифрует параметры запуска, полученные из "Центра запуска"
            </summary>
            <param name="InString"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Utils.DecryptXML(System.String)">
            <summary>
            Дешифрует параметры запуска, полученные из "Центра запуска" в виде XML
            </summary>
            <param name="xmlContent"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Utils.CheckLoginForCrypt(System.String@,System.String@)">
            <summary>
            Проверка на шифрование и (если нодо) дешифрует
            </summary>
            <param name="login"></param>
            <param name="pwd"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Utils.CheckArgsForProgramManager(System.String[],System.String@,System.String@)">
            <summary>
            Проверяет число параметров (если мало, то throw new Exception("Программа должна запускаться из центра запуска!"))
            возврашает результат CheckLoginForCrypt()
            </summary>
            <param name="args">Входные параметры программы</param>
            <param name="login">Готовый к применению</param>
            <param name="pwd">Готовый к применению</param>
            <returns>Результат CheckLoginForCrypt()</returns>
        </member>
        <member name="M:IT.Utils.SizeToString(System.Int64,System.Int32,System.Int32)">
            <summary>
            Формирование строки размера (файла)
            </summary>
            <param name="valueBytes"></param>
            <param name="criteriaCompare"></param>
            <param name="precision"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Utils.SizeFromString(System.String)">
            <summary>
            Преобразование размера в байтах из строки размера (из SizeToString)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Utils.UsingExclusive(System.Action)">
            <summary>
            Using Monitor to execute the act
            </summary>
            <param name="act"></param>
        </member>
        <member name="T:IT.UtilsReflection">
            <summary>
            Методы для упрощения работы с отражением
            </summary>
        </member>
        <member name="M:IT.UtilsReflection.GetFieldValue(System.Type,System.String)">
            <summary>
            Получает значение static поля (в том числе сложного)
            </summary>
            <param name="typ">Тип-владелец статического поля</param>
            <param name="propertyPath">Название свойства или путь</param>
            <returns></returns>
        </member>
        <member name="M:IT.UtilsReflection.GetFieldValue(System.Object,System.String)">
            <summary>
            Получает значение поля (в том числе сложного)
            </summary>
            <param name="obj">Расширяемый объект</param>
            <param name="propertyPath">Название свойства или путь</param>
            <returns></returns>
        </member>
        <member name="M:IT.UtilsReflection.GetPropertyValue(System.Object,System.String)">
            <summary>
            Получает значение свойства (в том числе сложного)
            </summary>
            <param name="obj">Расширяемый объект</param>
            <param name="propertyPath">Название свойства или путь</param>
        </member>
        <member name="M:IT.UtilsReflection.SetPropertyValue(System.Object,System.String,System.Object)">
            <summary>
            Устанавливаен значение свойства (в том числе сложного)
            </summary>
            <param name="obj">Расширяемый объект</param>
            <param name="propertyPath">Название свойства или путь</param>
            <param name="value">Знсчение</param>
        </member>
        <member name="M:IT.UtilsReflection.ExecStaticMethod``1(System.Type,System.String,System.Object[])">
            <summary>
            Выполняет статический метод из типа typ
            </summary>
            <typeparam name="T">Возвращаемое методом значение</typeparam>
            <param name="typ">Расширяемый тип</param>
            <param name="methodName">Название метода</param>
            <param name="args">Параметры метода (при использовании параметров out следует передавать реальный массив и потом из него читоать нужные элементы)</param>
            <returns></returns>
        </member>
        <member name="M:IT.UtilsReflection.ExecMethod(System.Object,System.String,System.Object[])">
            <summary>
            Выполняет метод
            </summary>
            <param name="obj">Расширяемый объект</param>
            <param name="methodName">Название емтода</param>
            <param name="args">Параметры метода</param>
            <returns></returns>
        </member>
        <member name="M:IT.UtilsReflection.ExecMethod``1(System.Object,System.String,System.Object[])">
            <summary>
            Выполняет метод
            </summary>
            <typeparam name="T">Тип результата</typeparam>
            <param name="obj">Расширяемый объект</param>
            <param name="methodName">Название емтода</param>
            <param name="args">Параметры метода</param>
            <returns></returns>
        </member>
        <member name="M:IT.UtilsReflection.ClonePropertyTo_PD(System.Object,System.Object,System.Boolean)">
            <summary>
            Пытается заполнить свойства переданного объекта собственными значениями соответствующих свойств
            используя PropertyDescription (уиитываются атрибуты : ReadOnly(), ...)
            </summary>
            <param name="source">Расширяемый экземпляр</param>
            <param name="dest">Объект для заполнения соответствующих свойств</param>
            <param name="isIcgnoreCase">Параметр сравнения наименованй свойств</param>
            <returns>Объект с заполнеными соответствующими свойствами</returns>
        </member>
        <member name="M:IT.UtilsReflection.ClonePropertyTo``1(System.Object,``0,System.Boolean)">
            <summary>
            Пытается заполнить свойства переданного объекта значениями соответствующих свойств source, используя PropertyInfo;
            так же пытается применить ICloneable для внутренних объектов
            (без рекурсии, т.е. сложные объекты могут иметь одинаковые ссылки на свойства) 
            </summary>
            <typeparam name="T">Тип результата</typeparam>
            <param name="source">Расширяемый экземпляр</param>
            <param name="dest">Объект для заполнения соответствующих свойств</param>
            <param name="isIcgnoreCase">Параметр сравнения наименованй свойств</param>
            <returns>Объект с заполнеными соответствующими свойствами</returns>
        </member>
        <member name="M:IT.UtilsReflection.CloneObject``1(``0,System.Func{``0})">
            <summary>
            Клонирует заданный объект используя указанный конструктор, так же учитывает ICloneable
            (внутренние объекты должны иметь конструкторы без параметров!)
            </summary>
            <typeparam name="T">Тип результата</typeparam>
            <param name="source"></param>
            <param name="constructor"></param>
            <returns></returns>
        </member>
        <member name="M:IT.UtilsReflection.CloneObject``1(``0)">
            <summary>
            Клонирует заданный объект используя конструктор без параметров
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:IT.Log.Logger">
            <summary>
            Вспомогательный класс для логирования
            получение методов - дорогое удовольствие : https://rsdn.ru/forum/dotnet/3309060.flat	
            </summary>
        </member>
        <member name="E:IT.Log.Logger.MessageSmall">
            <summary>
            Сообщение о возникновении записи в логе (не требует ссылки на NLog.dll) ASYNC !!!
            </summary>
        </member>
        <member name="P:IT.Log.Logger.MinLevel">
            <summary>
            Минимальный уровень срабатывания Logger
            </summary>
        </member>
        <member name="P:IT.Log.Logger.Include_Ip">
            <summary>
            Следует ли в лог влючать Ip данного компьютера в каждое сообщение лога
            </summary>
        </member>
        <member name="P:IT.Log.Logger.Include_ThreadId">
            <summary>
            Включать id потока
            </summary>
        </member>
        <member name="P:IT.Log.Logger.Include_Line">
            <summary>
            Включать № строки в исходном файле
            </summary>
        </member>
        <member name="P:IT.Log.Logger.Include_Method">
            <summary>
            Включать название метода
            </summary>
        </member>
        <member name="M:IT.Log.Logger.GetMsg_Ext(System.String,System.Object[])">
            <summary>
            Получает StackFrame и дополняет сообщение на онове информации StackFrame 
            </summary>
            <param name="msg"></param>
            <param name="args">Аргументы метода</param>
            <returns></returns>
        </member>
        <member name="M:IT.Log.Logger.ToLogFmt(System.Object,System.Diagnostics.TraceLevel,System.Exception,System.String,System.Object[])">
            <summary>
            Асинхронная отправка сообщений подписчикам + непосредственно запись в NLogger
            </summary>
            <param name="source">Класс-источник логирования</param>
            <param name="level"></param>
            <param name="ex"></param>
            <param name="msg"></param>
            <param name="args">Аргументы метода</param>
        </member>
        <member name="M:IT.Log.Logger.ToLog(System.Object,System.Diagnostics.TraceLevel,System.String,System.Exception)">
            <summary>
            Асинхронная отправка сообщений подписчикам + запись в System.Diagnostics.Debug
            </summary>
            <param name="source">Класс-источник логирования</param>
            <param name="level"></param>
            <param name="msg"></param>
            <param name="ex"></param>
        </member>
        <member name="M:IT.Log.Logger.GetMsg_Method(System.Diagnostics.StackFrame,System.String)">
            <summary>
            Дополняет сообщение на онове информации StackFrame 
            </summary>
            <param name="sf"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Log.Logger.GetMsgInternal(System.String)">
            <summary>
            окончательное формирование сообщения
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="T:IT.Zip">
            <summary>
            Расширения для сжатия
            </summary>
        </member>
        <member name="M:IT.Zip.FromGZip(System.IO.Stream)">
            <summary>
            Распаковка потока посредством GZip в новый MemoryStream
            </summary>
            <param name="inStr"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Zip.ToGZip(System.IO.Stream)">
            <summary>
            Упаковка потока посредством GZip в новый MemoryStream
            </summary>
            <param name="inStr"></param>
            <returns></returns>
        </member>
        <member name="M:IT.Zip.GZip(System.IO.Stream,System.IO.Stream,System.IO.Compression.CompressionMode)">
            <summary>
            Работа с потоками посредством GZip + outStr.Position = 0
            </summary>
            <param name="inStr"></param>
            <param name="outStr"></param>
            <param name="mode"></param>
        </member>
        <member name="T:System.Collections.ObjectModel.ObservableCollectionEx`1">
            <summary>
            Исправленная ObservableCollection
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:System.Collections.ObjectModel.ObservableCollectionEx`1.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:System.Collections.ObjectModel.ObservableCollectionEx`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="E:System.Collections.ObjectModel.ObservableCollectionEx`1.CollectionChanged">
            <summary>
            Перекрытое Событие
            </summary>
        </member>
        <member name="M:System.Collections.ObjectModel.ObservableCollectionEx`1.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Запист события
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:System.Collections.ObjectModel.ObservableCollectionEx`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Добавляет несколько объектов в конец System.Collections.ObjectModel.Collection&lt;T>
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:System.Collections.ObjectModel.ObservableCollectionEx`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="collection"></param>
        </member>
        <member name="M:System.Collections.ObjectModel.ObservableCollectionEx`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="count"></param>
        </member>
    </members>
</doc>
